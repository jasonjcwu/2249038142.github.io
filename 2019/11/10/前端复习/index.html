<!-- build time:Sat Apr 04 2020 09:25:24 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="alternate" href="/atom.xml" title="Jason's Blog" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:"flat",style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="一、CSS问题1.flex布局display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是"><meta name="keywords" content="javascript,css"><meta property="og:type" content="article"><meta property="og:title" content="前端复习题"><meta property="og:url" content="http://yoursite.com/2019/11/10/前端复习/index.html"><meta property="og:site_name" content="Jason&#39;s Blog"><meta property="og:description" content="一、CSS问题1.flex布局display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-12-01T02:17:04.819Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="前端复习题"><meta name="twitter:description" content="一、CSS问题1.flex布局display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是"><link rel="canonical" href="http://yoursite.com/2019/11/10/前端复习/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>前端复习题 | Jason's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Jason's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">佳宸学习和分享笔记的地方</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/2249038142" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/前端复习/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="吴佳宸"><meta itemprop="description" content="前端博客"><meta itemprop="image" content="/images/myHead.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jason's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端复习题</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-10 21:42:40" itemprop="dateCreated datePublished" datetime="2019-11-10T21:42:40+08:00">2019-11-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/复习/" itemprop="url" rel="index"><span itemprop="name">复习</span> </a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2019/11/10/前端复习/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/11/10/前端复习/" itemprop="commentCount"></span></a></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span>35k</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="一、CSS问题"><a href="#一、CSS问题" class="headerlink" title="一、CSS问题"></a>一、CSS问题</h3><h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><blockquote><p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p></blockquote><a id="more"></a><h4 id="2-css3的新特性"><a href="#2-css3的新特性" class="headerlink" title="2.css3的新特性"></a>2.css3的新特性</h4><blockquote><p>transtion transition-property 规定设置过渡效果的 CSS 属性的名称。</p></blockquote><blockquote><p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p></blockquote><blockquote><p>transition-timing-function 规定速度效果的速度曲线。</p></blockquote><blockquote><p>transition-delay 定义过渡效果何时开始。</p></blockquote><blockquote><p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p></blockquote><blockquote><p>ainimation实现动画效果主要由两部分组成：</p></blockquote><blockquote><p>通过类似Flash动画中的帧来声明一个动画；</p></blockquote><blockquote><p>在animation属性中调用关键帧声明的动画。</p></blockquote><blockquote><p>translate 3D建模效果</p></blockquote><h4 id="3-img中alt和title的区别"><a href="#3-img中alt和title的区别" class="headerlink" title="3.img中alt和title的区别"></a>3.img中alt和title的区别</h4><blockquote><p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化</p></blockquote><blockquote><p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p></blockquote><h4 id="4-用纯CSS创建一个三角形"><a href="#4-用纯CSS创建一个三角形" class="headerlink" title="4.用纯CSS创建一个三角形"></a>4.用纯CSS创建一个三角形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line">        border-top: 40px solid transparent;</span><br><span class="line">        border-left: 40px solid transparent;</span><br><span class="line">        border-right: 40px solid transparent;</span><br><span class="line">        border-bottom: 40px solid #ff0000;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-如何理解CSS的盒子模型？"><a href="#5-如何理解CSS的盒子模型？" class="headerlink" title="5.如何理解CSS的盒子模型？"></a>5.如何理解CSS的盒子模型？</h4><blockquote><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p></blockquote><blockquote><p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p></blockquote><h4 id="6-如何让一个div水平居中"><a href="#6-如何让一个div水平居中" class="headerlink" title="6.如何让一个div水平居中"></a>6.如何让一个div水平居中</h4><blockquote><p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p></blockquote><blockquote><p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p></blockquote><h4 id="7-如何让一个div水平垂直居中"><a href="#7-如何让一个div水平垂直居中" class="headerlink" title="7.如何让一个div水平垂直居中"></a>7.如何让一个div水平垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">position: relative / fixed; /* 相对定位或绝对定位均可 */</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-top:-150px;</span><br><span class="line">margin-left:-250px;</span><br><span class="line"> 外边距为自身宽高的一半 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-items: center; /* 垂直居中 */</span><br><span class="line">justify-content: center; /* 水平居中 */</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">width: 100px; /* 可省 */</span><br><span class="line">height: 100px; /* 可省 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-如何清除浮动？"><a href="#8-如何清除浮动？" class="headerlink" title="8.如何清除浮动？"></a>8.如何清除浮动？</h4><blockquote><p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;}</p></blockquote><blockquote><p>给浮动元素父级设置高度</p></blockquote><blockquote><p>父级同时浮动（需要给父级同级元素添加浮动）</p></blockquote><blockquote><p>父级设置成inline-block，其margin: 0 auto居中方式失效</p></blockquote><blockquote><p>给父级添加overflow:hidden 清除浮动方法</p></blockquote><blockquote><p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float_div:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">clear:both;</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">overflow:hidden;</span><br><span class="line">visibility:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.float_div&#123;</span><br><span class="line">zoom:1</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-css3实现三栏布局，左右固定，中间自适应"><a href="#9-css3实现三栏布局，左右固定，中间自适应" class="headerlink" title="9.css3实现三栏布局，左右固定，中间自适应"></a>9.css3实现三栏布局，左右固定，中间自适应</h4><blockquote><p>圣杯布局/双飞翼布局</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle,</span><br><span class="line">        .left,</span><br><span class="line">        .right &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">            min-height: 130px;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            padding: 0 220px 0 200px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            left: -200px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            margin-left: -220px;</span><br><span class="line">            right: -220px;</span><br><span class="line">            width: 220px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            background: blue;</span><br><span class="line">            word-break: break-all;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&apos;container&apos;&gt;</span><br><span class="line">        &lt;div class=&apos;middle&apos;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&apos;left&apos;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&apos;right&apos;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-display-none-和-visibility-hidden的区别"><a href="#10-display-none-和-visibility-hidden的区别" class="headerlink" title="10.display:none 和 visibility: hidden的区别"></a>10.display:none 和 visibility: hidden的区别</h4><blockquote><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p></blockquote><blockquote><p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p></blockquote><h4 id="11-CSS中-link-和-import-的区别是？"><a href="#11-CSS中-link-和-import-的区别是？" class="headerlink" title="11.CSS中 link 和@import 的区别是？"></a>11.CSS中 link 和@import 的区别是？</h4><blockquote><p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p></blockquote><blockquote><p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p></blockquote><blockquote><p>link方式的样式的权重 高于@import的权重.</p></blockquote><h4 id="12-position的absolute与fixed共同点与不同点"><a href="#12-position的absolute与fixed共同点与不同点" class="headerlink" title="12.position的absolute与fixed共同点与不同点"></a>12.position的absolute与fixed共同点与不同点</h4><blockquote><p>共同点： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上</p></blockquote><blockquote><p>不同点： absolute的”根元素“是可以设置的 fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p></blockquote><h4 id="13-transition和animation的区别"><a href="#13-transition和animation的区别" class="headerlink" title="13..transition和animation的区别"></a>13..transition和animation的区别</h4><blockquote><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性， 而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p></blockquote><blockquote><p>transition 规定动画的名字 规定完成过渡效果需要多少秒或毫秒 规定速度效果 定义过渡效果何时开始 animation 指定要绑定到选择器的关键帧的名称</p></blockquote><h4 id="14-CSS优先级"><a href="#14-CSS优先级" class="headerlink" title="14.CSS优先级"></a>14.CSS优先级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">不同级别：总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</span><br><span class="line">	1.属性后面加!import 会覆盖页面内任何位置定义的元素样式</span><br><span class="line">	2.作为style属性写在元素内的样式</span><br><span class="line">	3.id选择器</span><br><span class="line">	4.类选择器</span><br><span class="line">	5.标签选择器</span><br><span class="line">	6.通配符选择器（*）</span><br><span class="line">	7.浏览器自定义或继承</span><br><span class="line">**同一级别：后写的会覆盖先写的**</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p></blockquote><h4 id="15-雪碧图："><a href="#15-雪碧图：" class="headerlink" title="15.雪碧图："></a>15.雪碧图：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        多个图片集成在一个图片中的图</span><br><span class="line">	使用雪碧图可以减少网络请求的次数，加快允许的速度</span><br><span class="line">	通过background-position，去定位图片在屏幕的哪个位置</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="二、JS问题"><a href="#二、JS问题" class="headerlink" title="二、JS问题"></a>二、JS问题</h1><h4 id="1-typeof和instance-of-检测数据类型有什么区别？"><a href="#1-typeof和instance-of-检测数据类型有什么区别？" class="headerlink" title="1.typeof和instance of 检测数据类型有什么区别？"></a>1.typeof和instance of 检测数据类型有什么区别？</h4><blockquote><p>相同点： 都常用来判断一个变量是否为空，或者是什么类型的。</p></blockquote><blockquote><p>不同点： typeof 返回值是一个字符串，用来说明变量的数据类型 instanceof 用于判断一个变量是否属于某个对象的实例.</p></blockquote><h4 id="16-使元素消失的方法"><a href="#16-使元素消失的方法" class="headerlink" title="16.使元素消失的方法"></a>16.使元素消失的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visibility:hidden、display:none、z-index=-1、opacity：0</span><br><span class="line">1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发</span><br><span class="line">2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</span><br><span class="line">3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="谈一谈深克隆和浅克隆？"><a href="#谈一谈深克隆和浅克隆？" class="headerlink" title=".谈一谈深克隆和浅克隆？"></a>.谈一谈深克隆和浅克隆？</h4><blockquote><p>浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p></blockquote><blockquote><p>深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()</p></blockquote><h4 id="3-es6的新特性都有哪些？"><a href="#3-es6的新特性都有哪些？" class="headerlink" title="3.es6的新特性都有哪些？"></a>3.es6的新特性都有哪些？</h4><blockquote><p>let定义块级作用域变量 没有变量的提升，必须先声明后使用 let声明的变量，不能与前面的let，var，conset声明的变量重名</p></blockquote><blockquote><p>const 定义只读变量 const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改 const声明变量也是一个块级作用域变量 const声明的变量没有“变量的提升”，必须先声明后使用 const声明的变量不能与前面的let， var ， const声明的变量重 const定义的对象\数组中的属性值可以修改,基础数据类型不可以</p></blockquote><blockquote><p>ES6可以给形参函数设置默认值</p></blockquote><blockquote><p>在数组之前加上三个点（…）展开运算符</p></blockquote><blockquote><p>数组的解构赋值、对象的解构赋值</p></blockquote><blockquote><p>箭头函数的特点 箭头函数相当于匿名函数，是不能作为构造函数的，不能被new 箭头函数没有arguments实参集合,取而代之用…剩余运算符解决 箭头函数没有自己的this。他的this是继承当前上下文中的this 箭头函数没有函数原型 箭头函数不能当做Generator函数，不能使用yield关键字 不能使用call、apply、bind改变箭头函数中this指向 Set数据结构，数组去重</p></blockquote><h4 id="4-和-区别是什么？"><a href="#4-和-区别是什么？" class="headerlink" title="4.==和===区别是什么？"></a>4.==和===区别是什么？</h4><blockquote><p>=赋值</p></blockquote><blockquote><p>==返回一个布尔值；相等返回true，不相等返回false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址</p></blockquote><blockquote><p>=== 只要数据类型不一样，就返回false；</p></blockquote><h4 id="5-常见的设计模式有哪些？"><a href="#5-常见的设计模式有哪些？" class="headerlink" title="5.常见的设计模式有哪些？"></a>5.常见的设计模式有哪些？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、js工厂模式</span><br><span class="line">2、js构造函数模式</span><br><span class="line">3、js原型模式</span><br><span class="line">4、构造函数+原型的js混合模式</span><br><span class="line">5、构造函数+原型的动态原型模式</span><br><span class="line">6、观察者模式</span><br><span class="line">7、发布订阅模式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-call-bind-apply-的区别？"><a href="#6-call-bind-apply-的区别？" class="headerlink" title="6.call bind apply 的区别？"></a>6.call bind apply 的区别？</h4><blockquote><p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p></blockquote><blockquote><p>call()和apply()的区别就在于，两者之间的参数。</p></blockquote><blockquote><p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p></blockquote><blockquote><p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是 直接执行该函数。他的参数和call()相同。</p></blockquote><h4 id="7-js继承方式有哪些？"><a href="#7-js继承方式有哪些？" class="headerlink" title="7.js继承方式有哪些？"></a>7.js继承方式有哪些？</h4><blockquote><p>原型链继承 核心： 将父类的实例作为子类的原型</p></blockquote><blockquote><p>构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p></blockquote><blockquote><p>实例继承 核心：为父类实例添加新特性，作为子类实例返回</p></blockquote><blockquote><p>拷贝继承</p></blockquote><blockquote><p>组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用</p></blockquote><blockquote><p>寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点</p></blockquote><h4 id="8-你怎样看待闭包？"><a href="#8-你怎样看待闭包？" class="headerlink" title="8.你怎样看待闭包？"></a>8.你怎样看待闭包？</h4><blockquote><p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p></blockquote><h4 id="9-你是如何理解原型和原型链的？"><a href="#9-你是如何理解原型和原型链的？" class="headerlink" title="9.你是如何理解原型和原型链的？"></a>9.你是如何理解原型和原型链的？</h4><blockquote><p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 <strong>proto</strong>存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过<strong>proto</strong>向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p></blockquote><h4 id="10-浏览器渲染的主要流程是什么"><a href="#10-浏览器渲染的主要流程是什么" class="headerlink" title="10.浏览器渲染的主要流程是什么?"></a>10.浏览器渲染的主要流程是什么?</h4><blockquote><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p></blockquote><h4 id="11-从输入url地址到页面相应都发生了什么？"><a href="#11-从输入url地址到页面相应都发生了什么？" class="headerlink" title="11.从输入url地址到页面相应都发生了什么？"></a>11.从输入url地址到页面相应都发生了什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器的地址栏输入URL并按下回车。</span><br><span class="line">2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。</span><br><span class="line">4、根据IP建立TCP连接（三次握手）。</span><br><span class="line">5、HTTP发起请求。</span><br><span class="line">6、服务器处理请求，浏览器接收HTTP响应。</span><br><span class="line">7、渲染页面，构建DOM树。</span><br><span class="line">8、关闭TCP连接（四次挥手）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="12-session、cookie、localStorage的区别"><a href="#12-session、cookie、localStorage的区别" class="headerlink" title="12.session、cookie、localStorage的区别"></a>12.session、cookie、localStorage的区别</h4><blockquote><p>相同点 都是保存在浏览器端，且同源的。</p></blockquote><blockquote><p>不同点</p></blockquote><ul><li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li><li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li><li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li></ul><h4 id="13-js中跨域方法"><a href="#13-js中跨域方法" class="headerlink" title="13.js中跨域方法"></a>13.js中跨域方法</h4><blockquote><p>同源策略（协议+端口号+域名要相同）</p></blockquote><blockquote><p>1、jsonp跨域(只能解决get） 原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p><blockquote><p>步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据</p></blockquote></blockquote><blockquote><p>2、document.domain 基础域名相同 子域名不同</p></blockquote><blockquote><p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></blockquote><blockquote><p>4、服务器设置对CORS的支持 原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></blockquote><blockquote><p>5、利用h5新特性window.postMessage()</p></blockquote><h4 id="14-前端有哪些页面优化方法"><a href="#14-前端有哪些页面优化方法" class="headerlink" title="14.前端有哪些页面优化方法?"></a>14.前端有哪些页面优化方法?</h4><ul><li>减少 HTTP请求数</li><li>从设计实现层面简化页面</li><li>合理设置 HTTP缓存</li><li>资源合并与压缩</li><li>合并 CSS图片，减少请求数的又一个好办法。</li><li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li><li>多图片网页使用图片懒加载。</li><li>在js中尽量减少闭包的使用</li><li>尽量合并css和js文件</li><li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li><li>减少对DOM的操作</li><li>在JS中避免“嵌套循环”和 “死循环”</li><li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li></ul><h4 id="15-Ajax的四个步骤"><a href="#15-Ajax的四个步骤" class="headerlink" title="15.Ajax的四个步骤"></a>15.Ajax的四个步骤</h4><blockquote><p>1.创建ajax实例</p></blockquote><blockquote><p>2.执行open 确定要访问的链接 以及同步异步</p></blockquote><blockquote><p>3.监听请求状态</p></blockquote><blockquote><p>4.发送请求</p></blockquote><h4 id="16-数组去重的方法"><a href="#16-数组去重的方法" class="headerlink" title="16.数组去重的方法"></a>16.数组去重的方法</h4><blockquote><p>ES6的set对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    var arr2 = arr.sort();</span><br><span class="line">    var res = [arr2[0]];</span><br><span class="line">    for(var i=1;i&lt;arr2.length;i++)&#123;</span><br><span class="line">        if(arr2[i] !== res[res.length-1])&#123;</span><br><span class="line">        res.push(arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">利用下标查询</span><br><span class="line"> function unique(arr)&#123;</span><br><span class="line">    var newArr = [arr[0]];</span><br><span class="line">    for(var i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">        newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return newArr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="17-ajax中get和post请求的区别"><a href="#17-ajax中get和post请求的区别" class="headerlink" title="17.ajax中get和post请求的区别"></a>17.ajax中get和post请求的区别</h4><ul><li>get 一般用于获取数据</li><li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li><li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li><li>get安全性较低</li><li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li><li>post 一般用于发送数据</li><li>post传递参数，需要把参数放进请求体中，发送给服务器；</li><li>post请求参数放进了请求体中，对大小没有要求；</li><li>post安全性比较高；</li><li>post请求不会走缓存；</li><li></li></ul><h4 id="18-ajax的状态码"><a href="#18-ajax的状态码" class="headerlink" title="18.ajax的状态码"></a>18.ajax的状态码</h4><blockquote><p>2开头</p></blockquote><ul><li>200 : 代表请求成功；</li></ul><blockquote><p>3开头</p></blockquote><ul><li>301 : 永久重定向；</li><li>302: 临时转移</li><li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li><li>307:临时重定向</li></ul><blockquote><p>以4开头的都是客户端的问题；</p></blockquote><ul><li>400 :数据/格式错误</li><li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li><li>404 : 路径错误，找不到文件</li></ul><blockquote><p>以5开头都是服务端的问题</p></blockquote><ul><li>500 : 服务器的问题</li><li>503: 超负荷；</li></ul><h4 id="19-移动端的兼容问题"><a href="#19-移动端的兼容问题" class="headerlink" title="19.移动端的兼容问题"></a>19.移动端的兼容问题</h4><ul><li><p>给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend</p></li><li><p>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。 用fastclick，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">github.com/ftlabs/fast…</a> 用preventDefault阻止a标签的click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}</p></li><li><p>设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</p></li><li><p>圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</p></li><li><p>设置用户截止缩放，一般写视口的时候就已经写好了。</p></li><li></li></ul><h4 id="20-JS中同步和异步-以及js的事件流"><a href="#20-JS中同步和异步-以及js的事件流" class="headerlink" title="20.JS中同步和异步,以及js的事件流"></a>20.JS中同步和异步,以及js的事件流</h4><blockquote><p>同步：在同一时间内做一件事情</p></blockquote><blockquote><p>异步：在同一时间内做多个事情 JS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p></blockquote><h4 id="21-JS中常见的异步任务"><a href="#21-JS中常见的异步任务" class="headerlink" title="21.JS中常见的异步任务"></a>21.JS中常见的异步任务</h4><blockquote><p>定时器、ajax、事件绑定、回调函数、async await、promise</p></blockquote><h4 id="22-TCP的三次握手和四次挥手"><a href="#22-TCP的三次握手和四次挥手" class="headerlink" title="22.TCP的三次握手和四次挥手"></a>22.TCP的三次握手和四次挥手</h4><blockquote><p>三次握手</p></blockquote><ul><li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li><li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li><li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li></ul><blockquote><p>四次挥手</p></blockquote><ul><li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li><li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li><li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li><li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li></ul><h4 id="23-为什么建立连接是三次握手，而断开连接是四次挥手呢"><a href="#23-为什么建立连接是三次握手，而断开连接是四次挥手呢" class="headerlink" title="23.为什么建立连接是三次握手，而断开连接是四次挥手呢?"></a>23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4><blockquote><blockquote><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote></blockquote><h4 id="24-DOM-diff原理"><a href="#24-DOM-diff原理" class="headerlink" title="24.DOM diff原理"></a>24.DOM diff原理</h4><blockquote><ul><li>如果元素类型发生变化，直接替换</li><li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li></ul></blockquote><h4 id="25-作用域"><a href="#25-作用域" class="headerlink" title="25.作用域"></a>25.作用域</h4><blockquote><p>全局作用域</p></blockquote><ul><li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个window对象 window是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下） 如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被var过，那么存储值是undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li></ul><blockquote><p>私有作用域</p></blockquote><ul><li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li></ul><blockquote><p>块级作用域</p></blockquote><ul><li>es6中新引入的一种作用域 在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错） 作用域链</li></ul><blockquote><p>上级作用域</p></blockquote><ul><li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li></ul><h4 id="26-Promise处理异步"><a href="#26-Promise处理异步" class="headerlink" title="26.Promise处理异步"></a>26.Promise处理异步</h4><blockquote><p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行 Promise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法) then()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject ajax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p></blockquote><h4 id="27-map和forEach的区别"><a href="#27-map和forEach的区别" class="headerlink" title="27.map和forEach的区别"></a>27.map和forEach的区别</h4><blockquote><p>相同点</p></blockquote><ul><li>都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组</li></ul><blockquote><p>不同点</p></blockquote><ul><li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li></ul><blockquote><blockquote><p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p></blockquote></blockquote><h4 id="28-async-await函数"><a href="#28-async-await函数" class="headerlink" title="28.async await函数"></a>28.async await函数</h4><blockquote><p>async/await函数是异步代码的新方式</p></blockquote><blockquote><p>async/await是基于promise实现的</p></blockquote><blockquote><p>async/await使异步代码更像同步代码</p></blockquote><blockquote><p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p></blockquote><blockquote><p>默认返回一个promise实例，不能被改变</p></blockquote><blockquote><p>await下面的代码是异步，后面的代码是同步的</p></blockquote><h4 id="29-this指向"><a href="#29-this指向" class="headerlink" title="29.this指向"></a>29.this指向</h4><blockquote><ul><li>全局作用域下的this指向window</li><li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li><li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li><li>自执行函数中的this永远指向window</li><li>定时器中函数的this指向window</li><li>构造函数中的this指向当前的实例</li><li>call、apply、bind可以改变函数的this指向</li><li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li></ul></blockquote><h4 id="30-原型"><a href="#30-原型" class="headerlink" title="30.原型"></a>30.原型</h4><blockquote><blockquote><p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象 prototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p></blockquote></blockquote><h4 id="31-异步回调（如何解决回调地狱）"><a href="#31-异步回调（如何解决回调地狱）" class="headerlink" title="31.异步回调（如何解决回调地狱）"></a>31.异步回调（如何解决回调地狱）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">promise、generator、async/await</span><br><span class="line"></span><br><span class="line">promise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理</span><br><span class="line">	  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱</span><br><span class="line">	  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）</span><br><span class="line">	  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败</span><br><span class="line">		promise.all() 里面状态都改变，那就会输出，得到一个数组</span><br><span class="line">		promise.race() 里面只有一个状态变为rejected或者fulfilled即输出</span><br><span class="line">		promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="32-前端事件流"><a href="#32-前端事件流" class="headerlink" title="32.前端事件流"></a>32.前端事件流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</span><br><span class="line">  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。</span><br><span class="line">      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。</span><br><span class="line">      3、冒泡阶段：事件又传播回文档</span><br><span class="line">   阻止冒泡事件event.stopPropagation()</span><br><span class="line">	  function stopBubble(e) &#123;</span><br><span class="line">    		if (e &amp;&amp; e.stopPropagation) &#123; // 如果提供了事件对象event 这说明不是IE浏览器</span><br><span class="line">      		e.stopPropagation()</span><br><span class="line">    		&#125; else &#123;</span><br><span class="line">      		window.event.cancelBubble = true //IE方式阻止冒泡</span><br><span class="line">    	      &#125;</span><br><span class="line">  		   &#125;</span><br><span class="line">   阻止默认行为event.preventDefault()</span><br><span class="line"> function stopDefault(e) &#123;</span><br><span class="line">    if (e &amp;&amp; e.preventDefault) &#123;</span><br><span class="line">      e.preventDefault()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // IE浏览器阻止函数器默认动作的行为</span><br><span class="line">      window.event.returnValue = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="33-事件如何先捕获后冒泡？"><a href="#33-事件如何先捕获后冒泡？" class="headerlink" title="33.事件如何先捕获后冒泡？"></a>33.事件如何先捕获后冒泡？</h4><blockquote><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p></blockquote><ul><li>哪些事件不支持冒泡事件：鼠标事件：mouserleave mouseenter 焦点事件：blur focus UI事件：scroll resize</li></ul><h4 id="34-如何判断一个变量是对象还是数组（prototype-toString-call-）。"><a href="#34-如何判断一个变量是对象还是数组（prototype-toString-call-）。" class="headerlink" title="34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。"></a>34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。</p></blockquote><blockquote><p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p></blockquote><blockquote><p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p></blockquote><blockquote><p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p></blockquote><blockquote><p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p></blockquote><h4 id="35-setTimeout-和-setInterval的机制"><a href="#35-setTimeout-和-setInterval的机制" class="headerlink" title="35.setTimeout 和 setInterval的机制"></a>35.setTimeout 和 setInterval的机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的</span><br><span class="line">待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="36-splice和slice、map和forEach、-filter-、reduce-的区别"><a href="#36-splice和slice、map和forEach、-filter-、reduce-的区别" class="headerlink" title="36.splice和slice、map和forEach、 filter()、reduce()的区别"></a>36.splice和slice、map和forEach、 filter()、reduce()的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，</span><br><span class="line"> 包含从start到end（不包含该元素）的数组方法</span><br><span class="line">	注意：该方法不会更新原数组，而是返回一个子数组</span><br><span class="line"> 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）</span><br><span class="line">	splice(index, howmany,item1,...itemx)</span><br><span class="line">		·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置</span><br><span class="line">		·howmany参数：必须，要删除的数量，</span><br><span class="line">		·item1..itemx:可选，向数组添加新项目</span><br><span class="line">3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据</span><br><span class="line">4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素</span><br><span class="line">5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值</span><br><span class="line">6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理	</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="VUE问题"><a href="#VUE问题" class="headerlink" title="VUE问题"></a>VUE问题</h1><h4 id="1-聊聊对vue的理解"><a href="#1-聊聊对vue的理解" class="headerlink" title="1.聊聊对vue的理解"></a>1.聊聊对vue的理解</h4><blockquote><p>vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p></blockquote><h4 id="2-V-model的原理是什么？"><a href="#2-V-model的原理是什么？" class="headerlink" title="2.V-model的原理是什么？"></a>2.V-model的原理是什么？</h4><blockquote><p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事</p><ul><li>原理 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li></ul></blockquote><h4 id="3-谈谈对生命周期的理解"><a href="#3-谈谈对生命周期的理解" class="headerlink" title="3.谈谈对生命周期的理解"></a>3.谈谈对生命周期的理解</h4><ul><li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li><li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li><li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li><li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li><li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li><li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li><li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li><li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li></ul><h4 id="4-VUE和REACT有什么区别？"><a href="#4-VUE和REACT有什么区别？" class="headerlink" title="4.VUE和REACT有什么区别？"></a>4.VUE和REACT有什么区别？</h4><blockquote><p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p></blockquote><blockquote><p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p></blockquote><h4 id="5-vuex的流程"><a href="#5-vuex的流程" class="headerlink" title="5.vuex的流程"></a>5.vuex的流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。</span><br><span class="line">mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中</span><br><span class="line">通过mapGetter来动态获取state中的值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-vuex有哪几种状态和属性"><a href="#6-vuex有哪几种状态和属性" class="headerlink" title="6.vuex有哪几种状态和属性"></a>6.vuex有哪几种状态和属性</h4><blockquote><ul><li>state中保存着共有数据，数据是响应式的</li><li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li><li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li><li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li><li>modules：模块化vuex</li></ul></blockquote><h4 id="7-vue路由的两种模式"><a href="#7-vue路由的两种模式" class="headerlink" title="7.vue路由的两种模式"></a>7.vue路由的两种模式</h4><blockquote><ul><li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li><li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li></ul><p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p></blockquote><h4 id="8-vue中-key-值的作用"><a href="#8-vue中-key-值的作用" class="headerlink" title="8.vue中 key 值的作用"></a>8.vue中 key 值的作用</h4><blockquote><p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p></blockquote><blockquote><p>key的作用主要是为了高效的更新虚拟DOM。</p></blockquote><h4 id="9-route和-router的区别"><a href="#9-route和-router的区别" class="headerlink" title="9$route和$router的区别"></a>9<code>$route</code>和<code>$router</code>的区别</h4><blockquote><ul><li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li><li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul></blockquote><h4 id="10-vue-router守卫"><a href="#10-vue-router守卫" class="headerlink" title="10.vue-router守卫"></a>10.vue-router守卫</h4><blockquote><ul><li>导航守卫 router.beforeEach 全局前置守卫</li></ul></blockquote><ul><li>to: Route: 即将要进入的目标（路由对象）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。</li><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// main.js 入口文件</span><br><span class="line">    import router from &apos;./router&apos;; // 引入路由</span><br><span class="line">    router.beforeEach((to, from, next) =&gt; &#123; </span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">    router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">    router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">      console.log(&apos;afterEach 全局后置钩子&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/foo&apos;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">    // 比如还未保存草稿，或者在用户离开前，</span><br><span class="line">    将setInterval销毁，防止离开之后，定时器还在调用。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="11-axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#11-axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="11.axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4><blockquote><p>请求后台资源的模块。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios -S装好</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。 js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p></blockquote><h4 id="12-vue修饰符"><a href="#12-vue修饰符" class="headerlink" title="12.vue修饰符"></a>12.vue修饰符</h4><ul><li>stop：阻止事件的冒泡</li><li>prevent：阻止事件的默认行为</li><li>once：只触发一次</li><li>self：只触发自己的事件行为时，才会执行</li></ul><h4 id="13-vue项目中的性能优化"><a href="#13-vue项目中的性能优化" class="headerlink" title="13.vue项目中的性能优化"></a>13.vue项目中的性能优化</h4><blockquote><p>1.不要在模板里面写过多表达式</p></blockquote><blockquote><p>2.循环调用子组件时添加key</p></blockquote><blockquote><p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p></blockquote><blockquote><p>4.尽量少用float，可以用flex</p></blockquote><blockquote><p>5.按需加载，可以用require或者import()按需加载需要的组件</p></blockquote><blockquote><p>6.路由懒加载</p></blockquote><h4 id="14-vue-extend和vue-component"><a href="#14-vue-extend和vue-component" class="headerlink" title="14.vue.extend和vue.component"></a>14.vue.extend和vue.component</h4><blockquote><ul><li>extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li><li>Vue.component 你可以创建 ，也可以取组件。</li></ul></blockquote><h3 id="常见的兼容问题"><a href="#常见的兼容问题" class="headerlink" title="常见的兼容问题"></a>常见的兼容问题</h3><blockquote><p>png24位的图片在iE6浏览器上出现背景 解决方案是做成PNG8.也可以引用一段脚本处理.</p></blockquote><blockquote><p>浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><blockquote><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p></blockquote><blockquote><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p></blockquote><h1 id="React问题"><a href="#React问题" class="headerlink" title="React问题"></a>React问题</h1><h4 id="1-react和vue的区别"><a href="#1-react和vue的区别" class="headerlink" title="1.react和vue的区别"></a>1.react和vue的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   =&gt;  相同点：</span><br><span class="line">	1.数据驱动页面，提供响应式的试图组件</span><br><span class="line">	2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范</span><br><span class="line">	3.数据流动单向，都支持服务器的渲染SSR</span><br><span class="line">	4.都有支持native的方法，react有React native， vue有wexx</span><br><span class="line">=&gt;  不同点：</span><br><span class="line">	1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的</span><br><span class="line">	2.数据渲染：大规模的数据渲染，react更快</span><br><span class="line">	3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目</span><br><span class="line">	4.开发风格：react推荐做法jsx + inline style把html和css都写在js了</span><br><span class="line">		    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-redux中的reducer（纯函数）"><a href="#2-redux中的reducer（纯函数）" class="headerlink" title="2.redux中的reducer（纯函数）"></a>2.redux中的reducer（纯函数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）</span><br><span class="line">更新state(这个state可以理解为上下累加器的结果）</span><br><span class="line">每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是&apos;自身消减&apos;(reduce),</span><br><span class="line">进而返回最新的state,这也就是典型reduce函数的用法：state -&gt;  action -&gt;  state</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3-react的refs"><a href="#3-react的refs" class="headerlink" title="3.react的refs"></a>3.react的refs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，</span><br><span class="line">它将接受地城dom元素或组件的已挂在实例，作为第一个参数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4-react中的keys"><a href="#4-react中的keys" class="headerlink" title="4.react中的keys"></a>4.react中的keys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-React的生命周期"><a href="#5-React的生命周期" class="headerlink" title="5.React的生命周期"></a>5.React的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">三个状态：Mounting(已插入真实的DOM）</span><br><span class="line">	  Updating(正在被重新渲染)</span><br><span class="line">	  Unmounting(已移除真实的DOM)</span><br><span class="line">componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，</span><br><span class="line">componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-React子组件向父组件传值"><a href="#6-React子组件向父组件传值" class="headerlink" title="6.React子组件向父组件传值"></a>6.React子组件向父组件传值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…"><a href="#7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…" class="headerlink" title="7.为什么虚拟DOM会提高性能 www.zhihu.com/question/29…"></a>7.为什么虚拟DOM会提高性能 <a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">www.zhihu.com/question/29…</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能</span><br><span class="line">具体实现步骤：</span><br><span class="line">	·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中</span><br><span class="line">        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异</span><br><span class="line">	·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-diff算法"><a href="#8-diff算法" class="headerlink" title="8.diff算法"></a>8.diff算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记</span><br><span class="line">3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面</span><br><span class="line">Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用</span><br><span class="line">react只会匹配相同的class的component（这里的class指的是组件的名字）</span><br><span class="line">合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制</span><br><span class="line">4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能	</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-简述下flux的思想"><a href="#9-简述下flux的思想" class="headerlink" title="9.简述下flux的思想"></a>9.简述下flux的思想</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flux的最大特点，就是数据的‘单向流动’</span><br><span class="line">1.用户访问View</span><br><span class="line">2.View发出用户的Action</span><br><span class="line">3.Dispatcher收到Action,要求state进行相应的更新</span><br><span class="line">4.store更新后，发出一个‘change’事件后，更新页面</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-reac性能优化是哪个周期函"><a href="#10-reac性能优化是哪个周期函" class="headerlink" title="10.reac性能优化是哪个周期函"></a>10.reac性能优化是哪个周期函</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，</span><br><span class="line">如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="11-react怎么划分业务组件和技术组件"><a href="#11-react怎么划分业务组件和技术组件" class="headerlink" title="11.react怎么划分业务组件和技术组件"></a>11.react怎么划分业务组件和技术组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根据组件的职责通常把组件分为UI组件和容器组件</span><br><span class="line">UI组件负责UI的呈现，容器组件负责管理数据和逻辑</span><br><span class="line">两者通过React-redux提供connect方法联系起来</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="12-setState"><a href="#12-setState" class="headerlink" title="12.setState"></a>12.setState</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列</span><br><span class="line">而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值	</span><br><span class="line">那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误</span><br><span class="line"></span><br><span class="line">同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state</span><br><span class="line"></span><br><span class="line">同步更新state:</span><br><span class="line">	setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。</span><br><span class="line">	第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行</span><br><span class="line">	也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步</span><br><span class="line"></span><br><span class="line">例子：componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">	fetch(&apos;https://test.com&apos;)</span><br><span class="line">    </span><br><span class="line">	.then((res) =&gt; res.json())</span><br><span class="line">    </span><br><span class="line">	.then(</span><br><span class="line">    (data) =&gt; &#123;</span><br><span class="line">this.setState(&#123; data:data &#125;);</span><br><span class="line">			StatusBar.setNetworkActivityIndicatorVisible(false);</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h4 id="一、webpack打包文件体积过大？（最终打包为一个js文件）"><a href="#一、webpack打包文件体积过大？（最终打包为一个js文件）" class="headerlink" title="一、webpack打包文件体积过大？（最终打包为一个js文件）"></a>一、webpack打包文件体积过大？（最终打包为一个js文件）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.异步加载模块</span><br><span class="line">2.提取第三库</span><br><span class="line">3.代码压缩</span><br><span class="line">4.去除不必要的插件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="二、如何优化webpack构建的性能"><a href="#二、如何优化webpack构建的性能" class="headerlink" title="二、如何优化webpack构建的性能"></a>二、如何优化webpack构建的性能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积</span><br><span class="line">		 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理</span><br><span class="line">		 3.对一些组件库采用按需加载，避免无用的代码</span><br><span class="line">二、减少目录检索范围</span><br><span class="line">		 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度</span><br><span class="line">	</span><br><span class="line">三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三、移动端的性能优化"><a href="#三、移动端的性能优化" class="headerlink" title="三、移动端的性能优化"></a>三、移动端的性能优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  1、首屏加载和按需加载，懒加载</span><br><span class="line">  2、资源预加载</span><br><span class="line">  3、图片压缩处理，使用base64内嵌图片</span><br><span class="line">  4、合理缓存dom对象</span><br><span class="line">  5、使用touchstart代替click（click 300毫秒的延迟）</span><br><span class="line">  6、利用transform:translateZ(0)，开启硬件GUP加速</span><br><span class="line">  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明</span><br><span class="line">  8、使用viewport固定屏幕渲染，加速页面渲染内容</span><br><span class="line">  9、尽量使用事件代理，避免直接事件绑定</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="四、Vue的SPA-如何优化加载速度"><a href="#四、Vue的SPA-如何优化加载速度" class="headerlink" title="四、Vue的SPA 如何优化加载速度"></a>四、Vue的SPA 如何优化加载速度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.减少入口文件体积</span><br><span class="line">2.静态资源本地缓存</span><br><span class="line">3.开启Gzip压缩</span><br><span class="line">4.使用SSR,nuxt.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、移动端300ms延迟"><a href="#五、移动端300ms延迟" class="headerlink" title="五、移动端300ms延迟"></a>五、移动端300ms延迟</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由来：</span><br><span class="line">300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，</span><br><span class="line">当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作</span><br><span class="line">因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕</span><br><span class="line">       </span><br><span class="line">解决方案：1.禁用缩放，设置meta标签 user-scalable=no</span><br><span class="line">	  2.fastclick.js</span><br><span class="line">		原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即</span><br><span class="line">		      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉</span><br><span class="line">fastclick.js还可以解决穿透问题</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、页面的重构；"><a href="#六、页面的重构；" class="headerlink" title="六、页面的重构；"></a>六、页面的重构；</h4><blockquote><p>在不改变外部行为的前提下，简化结构、添加可读性</p></blockquote><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><h4 id="一、状态码："><a href="#一、状态码：" class="headerlink" title="一、状态码："></a>一、状态码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  2XX（成功处理了请求状态）</span><br><span class="line">      200 服务器已经成功处理请求，并提供了请求的网页</span><br><span class="line">      201 用户新建或修改数据成功</span><br><span class="line">      202 一个请求已经进入后台</span><br><span class="line">      204 用户删除成功</span><br><span class="line">  3XX（每次请求使用的重定向不要超过5次）</span><br><span class="line">      304 网页上次请求没有更新，节省带宽和开销</span><br><span class="line">  4XX（表示请求可能出错，妨碍了服务器的处理）</span><br><span class="line">      400 服务器不理解请求的语法</span><br><span class="line">      401 用户没有权限（用户名，密码输入错误）</span><br><span class="line">      403 用户得到授权（401相反），但是访问被禁止</span><br><span class="line">      404 服务器找不到请求的网页，</span><br><span class="line">  5XX（表示服务器在处理请求的时候发生内部错误）</span><br><span class="line">      500 服务器遇到错误，无法完成请求</span><br><span class="line">      503 服务器目前无法使用（超载或停机维护）     </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销"><a href="#二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销" class="headerlink" title="二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销"></a>二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）</span><br><span class="line">2.304是	HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件</span><br><span class="line">3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A</span><br><span class="line">	并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304</span><br><span class="line"></span><br><span class="line">last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间</span><br><span class="line">		客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，</span><br><span class="line">		询问该事件之后文件是否被修改，没修改返回304</span><br><span class="line"></span><br><span class="line"> 有了Last-Modified，为什么还要用ETag？</span><br><span class="line">  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）</span><br><span class="line">  2、某些服务器不能精确的得到文件的最后修改时间</span><br><span class="line">  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get</span><br><span class="line"></span><br><span class="line">ETag，为什么还要用Last-Modified？</span><br><span class="line">  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改</span><br><span class="line">  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）</span><br><span class="line">  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三、get-post的区别"><a href="#三、get-post的区别" class="headerlink" title="三、get/post的区别"></a>三、get/post的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中</span><br><span class="line">2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制</span><br><span class="line">3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值</span><br><span class="line">4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="四、http协议的理解"><a href="#四、http协议的理解" class="headerlink" title="四、http协议的理解"></a>四、http协议的理解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议</span><br><span class="line">2.基于TCP/IP通信协议来传递数据（HTML，图片资源）</span><br><span class="line">3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统</span><br><span class="line">4.http请求信息request：</span><br><span class="line">	请求行（request line）、请求头部（header）,空行和请求数据四部分构成</span><br><span class="line"></span><br><span class="line">	请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</span><br><span class="line">	请求头部，用来说明服务器要使用的附加信息</span><br><span class="line">	空行，请求头部后面的空行是必须的</span><br><span class="line">	请求数据也叫主体，可以添加任意的其他数据。</span><br><span class="line">5.http相应信息Response</span><br><span class="line">	状态行、消息报头、空行和响应正文</span><br><span class="line"></span><br><span class="line">	状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成</span><br><span class="line">	消息报头，用来说明客户端要使用的一些附加信息</span><br><span class="line">	空行，消息报头后面的空行是必须的</span><br><span class="line">	响应正文，服务器返回给客户端的文本信息。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、http和https"><a href="#五、http和https" class="headerlink" title="五、http和https"></a>五、http和https</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密</span><br><span class="line">http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、http1-0-1-1-2-0的区别"><a href="#六、http1-0-1-1-2-0的区别" class="headerlink" title="六、http1.0 1.1 2.0的区别"></a>六、http1.0 1.1 2.0的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接</span><br><span class="line">节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）</span><br><span class="line">host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</span><br><span class="line"></span><br><span class="line">1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好</span><br><span class="line">2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量</span><br><span class="line">3.多路复用：一个连接可以并发处理多个请求</span><br><span class="line">4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="七、web缓存"><a href="#七、web缓存" class="headerlink" title="七、web缓存"></a>七、web缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本</span><br><span class="line">2.缓存的好处</span><br><span class="line">        （1）减少不必要的请求</span><br><span class="line">    （2）降低服务器的压力，减少服务器的消耗</span><br><span class="line">    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="八、常见的web安全及防护原理"><a href="#八、常见的web安全及防护原理" class="headerlink" title="八、常见的web安全及防护原理"></a>八、常见的web安全及防护原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，</span><br><span class="line">            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，</span><br><span class="line">            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。</span><br><span class="line">		防范：1.对用户输入进行校验</span><br><span class="line">		       2.不适用动态拼接sql</span><br><span class="line">2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。</span><br><span class="line">		        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息</span><br><span class="line">			防范：1.尽量采用post而不使用get提交表单</span><br><span class="line">			      2.避免cookie中泄漏用户的隐式</span><br><span class="line">3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求</span><br><span class="line">			举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据</span><br><span class="line">			防范：在客服端页面增加伪随机数，通过验证码</span><br><span class="line">XSS和CSRF的区别：</span><br><span class="line">   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包</span><br><span class="line">   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="九、CDN（内容分发网络）"><a href="#九、CDN（内容分发网络）" class="headerlink" title="九、CDN（内容分发网络）"></a>九、CDN（内容分发网络）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。</span><br><span class="line">2.关键技术：内容存储和分发技术中</span><br><span class="line">3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术</span><br><span class="line">	    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十、TCP三次握手-客服端和服务器端都需要确认各自可收发）"><a href="#十、TCP三次握手-客服端和服务器端都需要确认各自可收发）" class="headerlink" title="十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）"></a>十、TCP三次握手 (客服端和服务器端都需要确认各自可收发）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。</span><br><span class="line">第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段</span><br><span class="line">第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段</span><br><span class="line">第三次握手： 服务器端确认客服端收到了自己发送的报文段</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…"><a href="#十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…" class="headerlink" title="十一、从输入url到获取页面的完整过程  blog.csdn.net/samjustin1/…"></a>十一、从输入url到获取页面的完整过程 <a href="https://blog.csdn.net/samjustin1/article/details/52650520" target="_blank" rel="noopener">blog.csdn.net/samjustin1/…</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存</span><br><span class="line">2.浏览器与服务器建立tcp链接（三次握手）</span><br><span class="line">3.浏览器向服务器发送http请求(请求和传输数据）</span><br><span class="line">4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器</span><br><span class="line">5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤</span><br><span class="line">6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print"><a href="#十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print" class="headerlink" title="十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print"></a>十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树</span><br><span class="line">概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树</span><br><span class="line">      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）</span><br><span class="line">      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置</span><br><span class="line">      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点</span><br><span class="line"></span><br><span class="line">重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上</span><br><span class="line">	触发重绘的条件：改变元素外观属性。如：color，background-color等</span><br><span class="line">	重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观</span><br><span class="line">注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局</span><br><span class="line"></span><br><span class="line">重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。</span><br><span class="line">	每个页面都需要一次回流，就是页面第一次渲染的时候</span><br><span class="line"></span><br><span class="line">重排一定会影响重绘，但是重绘不一定会影响重排</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十三、为什么css放在顶部而js写在后面"><a href="#十三、为什么css放在顶部而js写在后面" class="headerlink" title="十三、为什么css放在顶部而js写在后面"></a>十三、为什么css放在顶部而js写在后面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了</span><br><span class="line">2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。</span><br><span class="line">3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验</span><br><span class="line"></span><br><span class="line">但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十四、存储方式与传输方式"><a href="#十四、存储方式与传输方式" class="headerlink" title="十四、存储方式与传输方式"></a>十四、存储方式与传输方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m</span><br><span class="line">2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响</span><br><span class="line">3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）</span><br><span class="line">4.localStroage: h5的本地存储，数据永久保存在客服端</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie，sessionStorage，localStorage"><a href="#cookie，sessionStorage，localStorage" class="headerlink" title="cookie，sessionStorage，localStorage"></a>cookie，sessionStorage，localStorage</h4><p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上 实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象 session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据 2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id sessionStorage，localStorage仅在本地保存 3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB 4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭 sessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储） localStorage始终有效</p><p>SessionStorage和localStorage区别： 1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中） 并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存 2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p><h4 id="token、cookie、session三者的理解？？？！！！"><a href="#token、cookie、session三者的理解？？？！！！" class="headerlink" title="token、cookie、session三者的理解？？？！！！"></a>token、cookie、session三者的理解？？？！！！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）</span><br><span class="line">    用户身份的验证方式    </span><br><span class="line"></span><br><span class="line">2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名</span><br><span class="line">    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）</span><br><span class="line"></span><br><span class="line">3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）</span><br><span class="line">    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）"><a href="#基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）" class="headerlink" title="基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）"></a>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  1、用户通过用户名和密码发送请求</span><br><span class="line">  2、服务器端验证</span><br><span class="line">  3、服务器端返回一个带签名的token，给客户端</span><br><span class="line">  4、客户端储存token，并且每次用于发送请求</span><br><span class="line">  5、服务器验证token并且返回数据</span><br><span class="line">  每一次请求都需要token</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</span><br><span class="line">  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="session与token区别"><a href="#session与token区别" class="headerlink" title="session与token区别"></a>session与token区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App</span><br><span class="line">  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，</span><br><span class="line">     token不能转移到其他的App，也不能转到其他用户上。（适用于App）</span><br><span class="line">  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"><a href="#Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）" class="headerlink" title="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"></a>Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）</span><br><span class="line">  2、安全性问题。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>一、观察者模式：<a href="https://juejin.im/post/5a14e9edf265da4312808d86" target="_blank" rel="noopener">juejin.im/post/5a14e9…</a> <a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">juejin.im/post/5af05d…</a> 在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系 简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p></blockquote><blockquote><p>二、发布-订阅者 有一个信息中介，过滤 耦合性低 它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p></blockquote><ul><li>-两者的区别： 1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信 2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。 3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（） 4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li></ul><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h4 id="一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…"><a href="#一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…" class="headerlink" title="一、两个栈实现一个队列，两个队列实现一个栈 www.cnblogs.com/MrListening…"></a>一、两个栈实现一个队列，两个队列实现一个栈 <a href="https://www.cnblogs.com/MrListening/p/5697459.html" target="_blank" rel="noopener">www.cnblogs.com/MrListening…</a></h4><h4 id="二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…"><a href="#二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…" class="headerlink" title="二、红黑树（解决二叉树依次插入多个节点时的线型排列） juejin.im/post/5a27c6…"></a>二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a href="https://juejin.im/post/5a27c6946fb9a04509096248" target="_blank" rel="noopener">juejin.im/post/5a27c6…</a></h4><h4 id="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…"><a href="#三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…" class="headerlink" title="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin.im/post/5a2ff8…"></a>三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a href="https://juejin.im/post/5a2ff8c651882533d0230a85" target="_blank" rel="noopener">juejin.im/post/5a2ff8…</a></h4><h4 id="四、十大排序"><a href="#四、十大排序" class="headerlink" title="四、十大排序"></a>四、十大排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。</span><br><span class="line">  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个</span><br><span class="line">	    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</span><br><span class="line">	    3.针对所有的元素重复以上的步骤，除了最后一个</span><br><span class="line">	    4.重复步骤1-3，直到排序完成。</span><br><span class="line">2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾</span><br><span class="line">  实现过程：</span><br><span class="line"></span><br><span class="line">3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入</span><br><span class="line">  实现过程：1.从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line">	    2.取出下一个元素，在已排序的元素序列中冲后向前扫描</span><br><span class="line">	    3.如果该元素（以排序）大于新元素，将元素向后移一位</span><br><span class="line">	    4.在取出一个元素，比较之前的，直到找到自己合适的位置</span><br><span class="line"></span><br><span class="line">4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序</span><br><span class="line"></span><br><span class="line">1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现</span><br><span class="line">  实现过程：1.从数组中挑出一个元素，成为一个基准</span><br><span class="line">	    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）</span><br><span class="line">		这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。</span><br><span class="line">	    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序</span><br><span class="line">算法实现： function quickSort (arr) &#123;</span><br><span class="line">		if （arr.length &lt;= 1） &#123;return arr&#125;</span><br><span class="line">		var destIndex = Math.floor(arr.length/2)</span><br><span class="line">		var left = [], right = [];</span><br><span class="line">		var dest = arr.splice(destIndex,1)[0];</span><br><span class="line">		for (var i =0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			if (arr[i]&lt;dest) &#123;</span><br><span class="line">			left.push(arr[i])</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">			right.push(arr[i]) &#125;</span><br><span class="line">		return quickSort(left).concat([dest],quickSort(right)</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。</span><br><span class="line">  实现过程：1.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、数组去重-juejin-im-post-5aed61…"><a href="#五、数组去重-juejin-im-post-5aed61…" class="headerlink" title="五、数组去重 juejin.im/post/5aed61…"></a>五、数组去重 <a href="https://juejin.im/post/5aed6110518825671b026bed#heading-6" target="_blank" rel="noopener">juejin.im/post/5aed61…</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.双重循环</span><br><span class="line">2.indexOf</span><br><span class="line">3.数组排序去重 最快你Olong</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">判断回文字符串：（递归的思想）</span><br><span class="line">	1.字符串分隔，倒转，聚合[...obj].reverse().join(&apos;&apos;)</span><br><span class="line">	2.字符串头部和尾部，逐次向中间检测 </span><br><span class="line">		实现：function isPalindrome(line) &#123;</span><br><span class="line">			line += &apos;&apos;;</span><br><span class="line">			for (var i=0,j=line.length-1;i&lt;j;i++,j--) &#123;</span><br><span class="line">				if (line.chartAt(i) !== line.chartAt(j) &#123;</span><br><span class="line">				return false</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">	3.递归</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="七、二分查找（有序数组的查找）"><a href="#七、二分查找（有序数组的查找）" class="headerlink" title="七、二分查找（有序数组的查找）"></a>七、二分查找（有序数组的查找）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数</span><br><span class="line"> (1) 一开始,数据范围覆盖整个数组。</span><br><span class="line"> (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。</span><br><span class="line"> (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T</span><br><span class="line">代码实现：function binarySearch (data, dest, start, end)&#123;</span><br><span class="line">		var end = end || data.length-1;</span><br><span class="line">		var start = start || 0;</span><br><span class="line">		var m = Math.floor((start+end)/2);</span><br><span class="line">		if (dest&lt;data[m])&#123;</span><br><span class="line">			return binarySearch(data, dest, 0, m-1)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return binarySearch(data, dest, m+1, end)</span><br><span class="line">		&#125;&#125;</span><br><span class="line">		return false</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h4 id="一、动手实现一个bind（原理通过apply，call）"><a href="#一、动手实现一个bind（原理通过apply，call）" class="headerlink" title="一、动手实现一个bind（原理通过apply，call）"></a>一、动手实现一个bind（原理通过apply，call）</h4><p>一句话概括：1.bind()返回一个新函数，并不会立即执行。<br>2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数<br>3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function (obj, arg) &#123;</span><br><span class="line">   var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">   var context = this;</span><br><span class="line">   var bound = function (newArg) &#123;</span><br><span class="line">   arg = arg.concat(Array.prototype.slice.call(newArg);</span><br><span class="line">   return context.apply(obj, arg)</span><br><span class="line">&#125;</span><br><span class="line">  var F =  function () &#123;&#125;  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程</span><br><span class="line">  F.prototype = context.prototype;</span><br><span class="line">  bound.prototype =  new F();</span><br><span class="line">  return bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、-AJAX-（异步的javascript和xml）"><a href="#二、-AJAX-（异步的javascript和xml）" class="headerlink" title="二、 AJAX （异步的javascript和xml）"></a>二、 AJAX （异步的javascript和xml）</h4><p>ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。<br>优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载<br>可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带<br>劣势：不支持back。对搜索引擎的支持比较弱；不容易调试<br>怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，<br>解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getData(url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象</span><br><span class="line">    xhr.open(&apos;get&apos;, url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份</span><br><span class="line">    xhr.send() //发送一个http请求</span><br><span class="line">    xhr.onreadystatechange = function () &#123;  //设置一个http请求状态的函数</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; xhr.status ==200) &#123;</span><br><span class="line">        console.log(xhr.responseText)  // 获取异步调用返回的数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Promise(getData(url)).resolve(data =&gt; data)</span><br><span class="line"></span><br><span class="line">	 AJAX状态码：0 - （未初始化）还没有调用send()方法</span><br><span class="line">		     1 - （载入）已调用send方法，正在发送请求</span><br><span class="line">		     2 - （载入完成呢）send()方法执行完成</span><br><span class="line">		     3 - （交互）正在解析相应内容</span><br><span class="line">		     4 - （完成）响应内容解析完成，可以在客户端调用了</span><br></pre></td></tr></table></figure><h4 id="三、函数节流（throttle）"><a href="#三、函数节流（throttle）" class="headerlink" title="三、函数节流（throttle）"></a>三、函数节流（throttle）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> function throttle (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        var previous = 0;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            context = this;</span><br><span class="line">            args = arguments;</span><br><span class="line">            if (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、函数防抖（dobounce）"><a href="#四、函数防抖（dobounce）" class="headerlink" title="四、函数防抖（dobounce）"></a>四、函数防抖（dobounce）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debounce (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            var context = this;</span><br><span class="line">            var args = arguments;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                func.apply(context,args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.clone = function() &#123;</span><br><span class="line">  var newObject = this.constructor === Array ? [] : &#123;&#125;  //对象的深拷贝 获取对应的构造函数 [] 或者 &#123;&#125;</span><br><span class="line">  for (let e in this) &#123; //遍历对象的属性 in  this[e]</span><br><span class="line">    newObject[e] = typeof this[e] === &apos;object&apos; ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、实现一个简单的Promise-https-juejin-im-post-5b2f02cd5188252b937548ab"><a href="#六、实现一个简单的Promise-https-juejin-im-post-5b2f02cd5188252b937548ab" class="headerlink" title="六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab"></a>六、实现一个简单的Promise <a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">  constructor (executor) &#123;   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。</span><br><span class="line">    this.status = &apos;pending&apos;,</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 成功存放的数组</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">     // 失败存放法数组</span><br><span class="line">     this.onRejectedCallbacks = [];</span><br><span class="line">    let resolve = (value) =&gt; &#123;</span><br><span class="line">      if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">        this.status = &apos;resolve&apos;;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let reject = (reason) =&gt; &#123;</span><br><span class="line">      if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">        this.status = &apos;reject&apos;;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  then (onFullFilled,onRejected) &#123;</span><br><span class="line">    if (this.status == &apos;resolved&apos;) &#123;</span><br><span class="line">      onFullFilled(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &apos;rejectd&apos;) &#123;</span><br><span class="line">      onRejected(this.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">      this.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">        onFullFilled(this.value);</span><br><span class="line">      &#125;)</span><br><span class="line">      this.onRejectedCallbacks.push(()=&gt; &#123;</span><br><span class="line">          onRejected(this.reason);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&apos;hello world&apos;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p.then((data) =&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;,(err) =&gt;&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="七、发布订阅者模式（观察者模式）"><a href="#七、发布订阅者模式（观察者模式）" class="headerlink" title="七、发布订阅者模式（观察者模式）"></a>七、发布订阅者模式（观察者模式）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var event = &#123;&#125;; // 发布者</span><br><span class="line">event.clientList = [] //发布者的缓存列表</span><br><span class="line"></span><br><span class="line">event.listen = function (fn) &#123;  // 增加订阅者函数</span><br><span class="line">  this.clientList.push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.trigger = function () &#123;  // 发布信息</span><br><span class="line">  for (var i =0;i&lt;this.clientList.length;i++) &#123;</span><br><span class="line">    var fn = this.clientList[i];</span><br><span class="line">    fn.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.listen (function(time) &#123;</span><br><span class="line">  console.log(&apos;正式上班时间为：&apos; +time)</span><br><span class="line">&#125;)</span><br><span class="line">event.trigger (&apos;2018/7&apos;)</span><br></pre></td></tr></table></figure><h4 id="八、手动写一个node服务器"><a href="#八、手动写一个node服务器" class="headerlink" title="八、手动写一个node服务器"></a>八、手动写一个node服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const server = http.createServer((req,res) =&gt; &#123;</span><br><span class="line">	if (reu.url == &apos;/&apos;) &#123;</span><br><span class="line">	const indexFile = fs.createReadStream(&apos;./index.html&apos;)</span><br><span class="line">	req.writeHead(200,&#123;&apos;context-Type&apos;:&apos;text/html;charset = utf8&#125;)</span><br><span class="line">	indexFile.pipe(res)</span><br><span class="line">&#125;</span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/javascript/" rel="tag"># javascript</a> <a href="/tags/css/" rel="tag"># css</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/11/05/深信服研发前端岗位实习面经/" rel="next" title="深信服研发前端岗位实习面经"><i class="fa fa-chevron-left"></i> 深信服研发前端岗位实习面经</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/11/17/企业级web开发流程/" rel="prev" title="企业级web开发流程">企业级web开发流程 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、CSS问题"><span class="nav-number">1.</span> <span class="nav-text">一、CSS问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-flex布局"><span class="nav-number">1.1.</span> <span class="nav-text">1.flex布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-css3的新特性"><span class="nav-number">1.2.</span> <span class="nav-text">2.css3的新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-img中alt和title的区别"><span class="nav-number">1.3.</span> <span class="nav-text">3.img中alt和title的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-用纯CSS创建一个三角形"><span class="nav-number">1.4.</span> <span class="nav-text">4.用纯CSS创建一个三角形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-如何理解CSS的盒子模型？"><span class="nav-number">1.5.</span> <span class="nav-text">5.如何理解CSS的盒子模型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-如何让一个div水平居中"><span class="nav-number">1.6.</span> <span class="nav-text">6.如何让一个div水平居中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-如何让一个div水平垂直居中"><span class="nav-number">1.7.</span> <span class="nav-text">7.如何让一个div水平垂直居中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-如何清除浮动？"><span class="nav-number">1.8.</span> <span class="nav-text">8.如何清除浮动？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-css3实现三栏布局，左右固定，中间自适应"><span class="nav-number">1.9.</span> <span class="nav-text">9.css3实现三栏布局，左右固定，中间自适应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-display-none-和-visibility-hidden的区别"><span class="nav-number">1.10.</span> <span class="nav-text">10.display:none 和 visibility: hidden的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-CSS中-link-和-import-的区别是？"><span class="nav-number">1.11.</span> <span class="nav-text">11.CSS中 link 和@import 的区别是？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-position的absolute与fixed共同点与不同点"><span class="nav-number">1.12.</span> <span class="nav-text">12.position的absolute与fixed共同点与不同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-transition和animation的区别"><span class="nav-number">1.13.</span> <span class="nav-text">13..transition和animation的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-CSS优先级"><span class="nav-number">1.14.</span> <span class="nav-text">14.CSS优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-雪碧图："><span class="nav-number">1.15.</span> <span class="nav-text">15.雪碧图：</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#二、JS问题"><span class="nav-number"></span> <span class="nav-text">二、JS问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-typeof和instance-of-检测数据类型有什么区别？"><span class="nav-number">0.1.</span> <span class="nav-text">1.typeof和instance of 检测数据类型有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-使元素消失的方法"><span class="nav-number">0.2.</span> <span class="nav-text">16.使元素消失的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谈一谈深克隆和浅克隆？"><span class="nav-number">0.3.</span> <span class="nav-text">.谈一谈深克隆和浅克隆？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-es6的新特性都有哪些？"><span class="nav-number">0.4.</span> <span class="nav-text">3.es6的新特性都有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-和-区别是什么？"><span class="nav-number">0.5.</span> <span class="nav-text">4.==和===区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-常见的设计模式有哪些？"><span class="nav-number">0.6.</span> <span class="nav-text">5.常见的设计模式有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-call-bind-apply-的区别？"><span class="nav-number">0.7.</span> <span class="nav-text">6.call bind apply 的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-js继承方式有哪些？"><span class="nav-number">0.8.</span> <span class="nav-text">7.js继承方式有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-你怎样看待闭包？"><span class="nav-number">0.9.</span> <span class="nav-text">8.你怎样看待闭包？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-你是如何理解原型和原型链的？"><span class="nav-number">0.10.</span> <span class="nav-text">9.你是如何理解原型和原型链的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-浏览器渲染的主要流程是什么"><span class="nav-number">0.11.</span> <span class="nav-text">10.浏览器渲染的主要流程是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-从输入url地址到页面相应都发生了什么？"><span class="nav-number">0.12.</span> <span class="nav-text">11.从输入url地址到页面相应都发生了什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-session、cookie、localStorage的区别"><span class="nav-number">0.13.</span> <span class="nav-text">12.session、cookie、localStorage的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-js中跨域方法"><span class="nav-number">0.14.</span> <span class="nav-text">13.js中跨域方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-前端有哪些页面优化方法"><span class="nav-number">0.15.</span> <span class="nav-text">14.前端有哪些页面优化方法?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-Ajax的四个步骤"><span class="nav-number">0.16.</span> <span class="nav-text">15.Ajax的四个步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-数组去重的方法"><span class="nav-number">0.17.</span> <span class="nav-text">16.数组去重的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-ajax中get和post请求的区别"><span class="nav-number">0.18.</span> <span class="nav-text">17.ajax中get和post请求的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-ajax的状态码"><span class="nav-number">0.19.</span> <span class="nav-text">18.ajax的状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-移动端的兼容问题"><span class="nav-number">0.20.</span> <span class="nav-text">19.移动端的兼容问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-JS中同步和异步-以及js的事件流"><span class="nav-number">0.21.</span> <span class="nav-text">20.JS中同步和异步,以及js的事件流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-JS中常见的异步任务"><span class="nav-number">0.22.</span> <span class="nav-text">21.JS中常见的异步任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-TCP的三次握手和四次挥手"><span class="nav-number">0.23.</span> <span class="nav-text">22.TCP的三次握手和四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-为什么建立连接是三次握手，而断开连接是四次挥手呢"><span class="nav-number">0.24.</span> <span class="nav-text">23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-DOM-diff原理"><span class="nav-number">0.25.</span> <span class="nav-text">24.DOM diff原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-作用域"><span class="nav-number">0.26.</span> <span class="nav-text">25.作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-Promise处理异步"><span class="nav-number">0.27.</span> <span class="nav-text">26.Promise处理异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-map和forEach的区别"><span class="nav-number">0.28.</span> <span class="nav-text">27.map和forEach的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-async-await函数"><span class="nav-number">0.29.</span> <span class="nav-text">28.async await函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-this指向"><span class="nav-number">0.30.</span> <span class="nav-text">29.this指向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-原型"><span class="nav-number">0.31.</span> <span class="nav-text">30.原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-异步回调（如何解决回调地狱）"><span class="nav-number">0.32.</span> <span class="nav-text">31.异步回调（如何解决回调地狱）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-前端事件流"><span class="nav-number">0.33.</span> <span class="nav-text">32.前端事件流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-事件如何先捕获后冒泡？"><span class="nav-number">0.34.</span> <span class="nav-text">33.事件如何先捕获后冒泡？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-如何判断一个变量是对象还是数组（prototype-toString-call-）。"><span class="nav-number">0.35.</span> <span class="nav-text">34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-setTimeout-和-setInterval的机制"><span class="nav-number">0.36.</span> <span class="nav-text">35.setTimeout 和 setInterval的机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-splice和slice、map和forEach、-filter-、reduce-的区别"><span class="nav-number">0.37.</span> <span class="nav-text">36.splice和slice、map和forEach、 filter()、reduce()的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VUE问题"><span class="nav-number"></span> <span class="nav-text">VUE问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-聊聊对vue的理解"><span class="nav-number">0.1.</span> <span class="nav-text">1.聊聊对vue的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-V-model的原理是什么？"><span class="nav-number">0.2.</span> <span class="nav-text">2.V-model的原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-谈谈对生命周期的理解"><span class="nav-number">0.3.</span> <span class="nav-text">3.谈谈对生命周期的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-VUE和REACT有什么区别？"><span class="nav-number">0.4.</span> <span class="nav-text">4.VUE和REACT有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-vuex的流程"><span class="nav-number">0.5.</span> <span class="nav-text">5.vuex的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-vuex有哪几种状态和属性"><span class="nav-number">0.6.</span> <span class="nav-text">6.vuex有哪几种状态和属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-vue路由的两种模式"><span class="nav-number">0.7.</span> <span class="nav-text">7.vue路由的两种模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-vue中-key-值的作用"><span class="nav-number">0.8.</span> <span class="nav-text">8.vue中 key 值的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-route和-router的区别"><span class="nav-number">0.9.</span> <span class="nav-text">9$route和$router的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-vue-router守卫"><span class="nav-number">0.10.</span> <span class="nav-text">10.vue-router守卫</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-axios是什么？怎么使用？描述使用它实现登录功能的流程？"><span class="nav-number">0.11.</span> <span class="nav-text">11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-vue修饰符"><span class="nav-number">0.12.</span> <span class="nav-text">12.vue修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-vue项目中的性能优化"><span class="nav-number">0.13.</span> <span class="nav-text">13.vue项目中的性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-vue-extend和vue-component"><span class="nav-number">0.14.</span> <span class="nav-text">14.vue.extend和vue.component</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的兼容问题"><span class="nav-number">1.</span> <span class="nav-text">常见的兼容问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React问题"><span class="nav-number"></span> <span class="nav-text">React问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-react和vue的区别"><span class="nav-number">0.1.</span> <span class="nav-text">1.react和vue的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-redux中的reducer（纯函数）"><span class="nav-number">0.2.</span> <span class="nav-text">2.redux中的reducer（纯函数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-react的refs"><span class="nav-number">0.3.</span> <span class="nav-text">3.react的refs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-react中的keys"><span class="nav-number">0.4.</span> <span class="nav-text">4.react中的keys</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-React的生命周期"><span class="nav-number">0.5.</span> <span class="nav-text">5.React的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-React子组件向父组件传值"><span class="nav-number">0.6.</span> <span class="nav-text">6.React子组件向父组件传值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…"><span class="nav-number">0.7.</span> <span class="nav-text">7.为什么虚拟DOM会提高性能 www.zhihu.com/question/29…</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-diff算法"><span class="nav-number">0.8.</span> <span class="nav-text">8.diff算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-简述下flux的思想"><span class="nav-number">0.9.</span> <span class="nav-text">9.简述下flux的思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-reac性能优化是哪个周期函"><span class="nav-number">0.10.</span> <span class="nav-text">10.reac性能优化是哪个周期函</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-react怎么划分业务组件和技术组件"><span class="nav-number">0.11.</span> <span class="nav-text">11.react怎么划分业务组件和技术组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-setState"><span class="nav-number">0.12.</span> <span class="nav-text">12.setState</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能优化"><span class="nav-number"></span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、webpack打包文件体积过大？（最终打包为一个js文件）"><span class="nav-number">0.1.</span> <span class="nav-text">一、webpack打包文件体积过大？（最终打包为一个js文件）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、如何优化webpack构建的性能"><span class="nav-number">0.2.</span> <span class="nav-text">二、如何优化webpack构建的性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、移动端的性能优化"><span class="nav-number">0.3.</span> <span class="nav-text">三、移动端的性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、Vue的SPA-如何优化加载速度"><span class="nav-number">0.4.</span> <span class="nav-text">四、Vue的SPA 如何优化加载速度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、移动端300ms延迟"><span class="nav-number">0.5.</span> <span class="nav-text">五、移动端300ms延迟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、页面的重构；"><span class="nav-number">0.6.</span> <span class="nav-text">六、页面的重构；</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务器端"><span class="nav-number"></span> <span class="nav-text">服务器端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、状态码："><span class="nav-number">0.1.</span> <span class="nav-text">一、状态码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销"><span class="nav-number">0.2.</span> <span class="nav-text">二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、get-post的区别"><span class="nav-number">0.3.</span> <span class="nav-text">三、get/post的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、http协议的理解"><span class="nav-number">0.4.</span> <span class="nav-text">四、http协议的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、http和https"><span class="nav-number">0.5.</span> <span class="nav-text">五、http和https</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、http1-0-1-1-2-0的区别"><span class="nav-number">0.6.</span> <span class="nav-text">六、http1.0 1.1 2.0的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、web缓存"><span class="nav-number">0.7.</span> <span class="nav-text">七、web缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八、常见的web安全及防护原理"><span class="nav-number">0.8.</span> <span class="nav-text">八、常见的web安全及防护原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#九、CDN（内容分发网络）"><span class="nav-number">0.9.</span> <span class="nav-text">九、CDN（内容分发网络）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十、TCP三次握手-客服端和服务器端都需要确认各自可收发）"><span class="nav-number">0.10.</span> <span class="nav-text">十、TCP三次握手 (客服端和服务器端都需要确认各自可收发）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…"><span class="nav-number">0.11.</span> <span class="nav-text">十一、从输入url到获取页面的完整过程 blog.csdn.net/samjustin1/…</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print"><span class="nav-number">0.12.</span> <span class="nav-text">十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十三、为什么css放在顶部而js写在后面"><span class="nav-number">0.13.</span> <span class="nav-text">十三、为什么css放在顶部而js写在后面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十四、存储方式与传输方式"><span class="nav-number">0.14.</span> <span class="nav-text">十四、存储方式与传输方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cookie，sessionStorage，localStorage"><span class="nav-number">0.15.</span> <span class="nav-text">cookie，sessionStorage，localStorage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#token、cookie、session三者的理解？？？！！！"><span class="nav-number">0.16.</span> <span class="nav-text">token、cookie、session三者的理解？？？！！！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）"><span class="nav-number">0.17.</span> <span class="nav-text">基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cookie与session区别"><span class="nav-number">0.18.</span> <span class="nav-text">cookie与session区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#session与token区别"><span class="nav-number">0.19.</span> <span class="nav-text">session与token区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"><span class="nav-number">0.20.</span> <span class="nav-text">Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-number"></span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构和算法"><span class="nav-number"></span> <span class="nav-text">数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…"><span class="nav-number">0.1.</span> <span class="nav-text">一、两个栈实现一个队列，两个队列实现一个栈 www.cnblogs.com/MrListening…</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…"><span class="nav-number">0.2.</span> <span class="nav-text">二、红黑树（解决二叉树依次插入多个节点时的线型排列） juejin.im/post/5a27c6…</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…"><span class="nav-number">0.3.</span> <span class="nav-text">三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin.im/post/5a2ff8…</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、十大排序"><span class="nav-number">0.4.</span> <span class="nav-text">四、十大排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、数组去重-juejin-im-post-5aed61…"><span class="nav-number">0.5.</span> <span class="nav-text">五、数组去重 juejin.im/post/5aed61…</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、字符串"><span class="nav-number">0.6.</span> <span class="nav-text">六、字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、二分查找（有序数组的查找）"><span class="nav-number">0.7.</span> <span class="nav-text">七、二分查找（有序数组的查找）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#手写代码"><span class="nav-number"></span> <span class="nav-text">手写代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、动手实现一个bind（原理通过apply，call）"><span class="nav-number">0.1.</span> <span class="nav-text">一、动手实现一个bind（原理通过apply，call）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、-AJAX-（异步的javascript和xml）"><span class="nav-number">0.2.</span> <span class="nav-text">二、 AJAX （异步的javascript和xml）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、函数节流（throttle）"><span class="nav-number">0.3.</span> <span class="nav-text">三、函数节流（throttle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、函数防抖（dobounce）"><span class="nav-number">0.4.</span> <span class="nav-text">四、函数防抖（dobounce）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><span class="nav-number">0.5.</span> <span class="nav-text">五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、实现一个简单的Promise-https-juejin-im-post-5b2f02cd5188252b937548ab"><span class="nav-number">0.6.</span> <span class="nav-text">六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、发布订阅者模式（观察者模式）"><span class="nav-number">0.7.</span> <span class="nav-text">七、发布订阅者模式（观察者模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八、手动写一个node服务器"><span class="nav-number">0.8.</span> <span class="nav-text">八、手动写一个node服务器</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/myHead.jpg" alt="吴佳宸"><p class="site-author-name" itemprop="name">吴佳宸</p><div class="site-description" itemprop="description">前端博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">60</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/2249038142" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;2249038142" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:jiachenwu@foxmail.com" title="E-Mail &amp;rarr; mailto:jiachenwu@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://lrnjy.club/" title="https:&#x2F;&#x2F;lrnjy.club" rel="noopener" target="_blank">后端伙伴李若宁</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">吴佳宸</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">225k</span></div></div></footer></div><script color="0,0,255" opacity="0.4" zindex="-1" count="30" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js"></script><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script><script src="/js/schemes/pisces.js?v=7.4.1"></script><script src="/js/next-boot.js?v=7.4.1"></script><script src="/js/local-search.js?v=7.4.1"></script><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'HJiiY7CXyweaq3HGMsePJ5LV-gzGzoHsz',
    appKey: '0pjCVXYHThWsdCCBmBD5TLwK',
    placeholder: "´▽`*(੭*ˊᵕˋ)੭*ଘ 有疑问请评论",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);</script><script>!function(t){function n(){for(var n=0;n<e.length;n++)i=e[n],0<=(o=i.getBoundingClientRect()).top&&0<=o.left&&o.top<=(t.innerHeight||document.documentElement.clientHeight)&&function(){var t,i,o,r,c=e[n];t=c,i=function(){e=e.filter(function(t){return c!==t})},o=new Image,r=t.getAttribute("data-original"),o.onload=function(){t.src=r,i&&i()},o.src=r}();var i,o}var e=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));n(),t.addEventListener("scroll",function(){var e,i;e=n,i=t,clearTimeout(e.tId),e.tId=setTimeout(function(){e.call(i)},500)})}(this)</script></body></html><!-- rebuild by neat -->