<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Blog</title>
  
  <subtitle>佳宸学习和分享笔记的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-13T09:48:51.904Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴佳宸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾佬700元装了台主流配置电脑</title>
    <link href="http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/"/>
    <id>http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/</id>
    <published>2020-01-13T08:58:09.874Z</published>
    <updated>2020-01-13T09:48:51.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="700元垃圾佬主机大升级"><a href="#700元垃圾佬主机大升级" class="headerlink" title="700元垃圾佬主机大升级"></a>700元垃圾佬主机大升级</h1><blockquote><p>事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>京东双十二买的酷兽 当时199 <strong>16G 2666MHz</strong> 的内存，用了个199 -15 的全品类券 ，白菜价<strong>184</strong>到手，单面2G*8颗粒组成16G容量，镁光颗粒。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/RAM2.jpg" alt="RAM2"><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/QK@@34LQC(W%7B)I@%7B%7DUIVT2.jpg" alt="img"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>最终选定一代锐龙，R5-1400 四核-八线程 基础频率3.2GHz。便宜就完事，全新带散热器淘宝只要350左右，其实9月就到这价格了，已经没有降价空间了。为了追求更便宜，买了咸鱼二手，cpu这种东西用不坏的，所以二手也稳。这块cpu也能稳定超频。唯一缺陷就是没有核心显卡，还得另外配，没显卡还是建议速龙3000G(APU).</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113114601686.png" alt="image-20200113114601686"></p><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>映泰tb350-etc，全新矿板，可装六张显卡，支持AM4处理器，7相供电，很稳定，矿难清库存还剩点，230入手。唯一的缺点就是，不支持MVME接口，只能装sata固态。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120344918.png" alt="image-20200113120344918"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120905439.png" alt="image-20200113120905439"></p><h3 id="硅脂"><a href="#硅脂" class="headerlink" title="硅脂"></a>硅脂</h3><p>淘宝特价版，5元红包，1.9元入手 ，看过一个测试硅脂的话，涂X形状就行，刮刀就往一边刮。<img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122109279.png" alt="image-20200113122109279"></p><hr><h3 id="总价"><a href="#总价" class="headerlink" title="总价"></a>总价</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122402817.png" alt="image-20200113122402817"></p><h3 id="不要钱系列"><a href="#不要钱系列" class="headerlink" title="不要钱系列"></a>不要钱系列</h3><h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>表哥有个闲置显卡，七彩虹GTX650，送给我了。玩玩普通网游还是无压力的。费米之后的开普勒架构很大程度上改善了高功耗、高发热问题。这里感谢翔哥。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113123036484.png" alt="image-20200113123036484"></p><h4 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h4><p>朗科480G固态，老爹闲置的固态。速度不快，但是够用，读写速度加上十秒开机。爽歪歪。</p><h4 id="机箱，机械硬盘，电源"><a href="#机箱，机械硬盘，电源" class="headerlink" title="机箱，机械硬盘，电源"></a>机箱，机械硬盘，电源</h4><p>全是祖传的</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163203557.png" alt="image-20200113163203557"></p><hr><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h3><ul><li>*<em>I tell you *</em>里面下载win10 企业版</li><li>一个大于8G U盘 ，格式化后 用 UltraISO 把系统搞到U盘</li><li>在BIOS里，设置U盘优先启动</li><li>Win 10激活 傻瓜式破解 链接: <a href="https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA</a> 提取码: 3fff （仅用于个人学习，商业用途概不负责）</li></ul><h3 id="安装基本软件"><a href="#安装基本软件" class="headerlink" title="安装基本软件"></a>安装基本软件</h3><p>下载的是win10企业版比较纯净。纯净到什么都没有。。。计算器，win商店都没有</p><p>win商店下载，进入商店之后edge浏览器等软件下载</p><p>链接: <a href="https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw" target="_blank" rel="noopener">https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw</a> 提取码: tia9</p><p>解压：<strong>bandzip</strong></p><p>杀毒：<strong>火绒</strong>，关闭垃圾软件广告弹窗</p><p><a href="https://link.zhihu.com/?target=http%3A//www.kbtool.cn/" target="_blank" rel="noopener">EX-DIY工具箱 卡硬工具箱 （原：卡吧工具箱）</a>，一个集合型工具，汇总了几大常用检测软件。</p><h3 id="超频"><a href="#超频" class="headerlink" title="超频"></a>超频</h3><p>基础的超频很简单，直接在bios里面，调频率就行了。一般超个10%很稳定的，再往上超就需要调节电压了。新手建议不加电压以免烧坏。就一步一步一点点加，加到黑屏的话直接扣下主板电池，主板就会恢复出厂设置。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163312898.png" alt="image-20200113163312898"></p><h4 id="cpu超频"><a href="#cpu超频" class="headerlink" title="cpu超频"></a>cpu超频</h4><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161954488.png" alt="image-20200113161954488"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161924106.png" alt="image-20200113161924106"></p><p>轻松超到3.7GHz，家里用就不继续超了，功耗会增加</p><h4 id="内存超频"><a href="#内存超频" class="headerlink" title="内存超频"></a>内存超频</h4><p>轻松超到2933MHz，等有钱了配个双通道32G 内存。再往上走，得调降低搬运时序了。</p><h4 id="显卡超频"><a href="#显卡超频" class="headerlink" title="显卡超频"></a>显卡超频</h4><p>NVIDIA Inspector是一款N卡专用的检测/超频软件，不但像GPU-Z一样可以检测显卡的各种信息，还能对显卡的频率、风扇转速甚至电压进行调节，十分实用。核心频率超100MHz和显存频率超200MHz，最后面的电压也不建议调，容易烧。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/L4CL2D%7D%5BJ_B5VSZ%7D%60%5BLDS45.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装机，重点是过程和玩，淘宝垃圾的过程，装机的过程。挺好玩的。总的来说这次700元装出3000元的逼了。</p><hr><h3 id="番外篇：晒好价外设"><a href="#番外篇：晒好价外设" class="headerlink" title="番外篇：晒好价外设"></a>番外篇：晒好价外设</h3><h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>酷冷至尊 k370 红轴，此款键盘的特点是 cherry原厂红轴，全键无冲，BPT键帽不易打油，有卫星轴，很重底层有钢板，预留灯位，想想一个红轴的单价都是2块，算算光轴的钱就超200了，199内还要啥自行车。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113164616416.png" alt="image-20200113164616416"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113165124122.png" alt="image-20200113165124122"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;a href=&quot;#700元垃圾佬主机大升级&quot; class=&quot;headerlink&quot; title=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;/a&gt;700元垃圾佬主机大升级&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Js深浅拷贝</title>
    <link href="http://yoursite.com/2020/01/11/Js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/01/11/Js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-01-11T05:08:11.772Z</published>
    <updated>2020-01-13T02:01:46.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS深浅拷贝"><a href="#JS深浅拷贝" class="headerlink" title="JS深浅拷贝"></a>JS深浅拷贝</h1><blockquote><p>要想深入的确实个值得探究的问题</p></blockquote><h4 id="首先明确两个概念"><a href="#首先明确两个概念" class="headerlink" title="首先明确两个概念"></a>首先明确两个概念</h4><ul><li><strong>基本数据类型</strong>：String、Number、Boolean、Null、Undefined、Symbol。基本数据类型是直接存储在栈中的数据。</li><li><strong>引用数据类型</strong>：Array、Object。引用数据类型在该对象在栈中存储的是<strong>引用地址</strong>，指向内存堆中真实的数据。</li></ul><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>所以说如果是引用类型数据的新赋值，会影响到原数据。</p><h4 id="深拷贝与浅拷贝的关系"><a href="#深拷贝与浅拷贝的关系" class="headerlink" title="深拷贝与浅拷贝的关系"></a>深拷贝与浅拷贝的关系</h4><ul><li><strong>浅拷贝</strong>：一层拷贝。修改子<strong>引用</strong>数据类型会<strong>影响原有</strong>的数据类型。</li><li><strong>深拷贝</strong>：无限层级拷贝。修改不会影响原有的数据类型。因为指针指向的堆是新开辟的。</li></ul><h3 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  a: <span class="number">1</span>, </span><br><span class="line">  b: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  d: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//(target,...source) 把obj对象赋到空对象 在给copy变量</span></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); </span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">copy.a = <span class="number">3</span>;</span><br><span class="line">copy.d = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">copy.b.c = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); </span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>第一层引用类型数据是深拷贝</strong>，对于<strong>第二层及以上</strong>的引用类型数据来说，是<strong>浅拷贝</strong>。</p><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200108123043489.png" alt="image-20200108123043489"></p><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h4><p>对象的浅拷贝</p><blockquote><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a>Array.prototype.concat</h4><p><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">MDN</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat 方法例子</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"><span class="keyword">const</span> array3 = array1.concat(array2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array3);</span><br><span class="line"><span class="comment">// expected output: Array ["a", "b", "c", "d", "e", "f"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝一个数组</span></span><br><span class="line"><span class="comment">// 直接执行函数空参数，然后赋值给变量就是浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, &#123;<span class="attr">c</span>: <span class="string">'deep C'</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> copyArr = array.concat()</span><br><span class="line">copyArr[<span class="number">0</span>] = <span class="string">'change A'</span></span><br><span class="line">copyArr[<span class="number">2</span>].c = <span class="string">'change Deep C'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"><span class="comment">// array: [ 'a', 'b', &#123; c: 'change Deep C' &#125; ]  引用类型数据源被改变</span></span><br><span class="line"><span class="built_in">console</span>.log(copyArr)</span><br><span class="line"><span class="comment">// copyArr: [ 'change A', 'b', &#123; c: 'change Deep C' &#125; ]</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200108210018080.png" alt="image-20200108210018080"></p><h4 id="Array-prototype-clice"><a href="#Array-prototype-clice" class="headerlink" title="Array.prototype.clice"></a>Array.prototype.clice</h4><p><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">'ant'</span>, <span class="string">'bison'</span>, <span class="string">'camel'</span>, <span class="string">'duck'</span>, <span class="string">'elephant'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck", "elephant"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以说slice传空参数就是浅拷贝</span></span><br><span class="line">animals.clice()</span><br></pre></td></tr></table></figure><h4 id="…展开运算符"><a href="#…展开运算符" class="headerlink" title="…展开运算符"></a>…展开运算符</h4><p>此法最简单实用ES6</p><p><code>const objCopy = {...source}</code></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>手写深拷贝，通过判断数组和对象然后 递归+浅拷贝实现</p><h4 id="解决死循环"><a href="#解决死循环" class="headerlink" title="解决死循环"></a>解决死循环</h4><p>这样子循环嵌套，就会进入死循环，使用递归拷贝不会停止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">obj1.a = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(deepClone(obj1));</span><br></pre></td></tr></table></figure><p>设置hash表，避免出现重复嵌套的死循环。</p><p>如果hash表中由此值时，直接退出</p><blockquote><p><strong><code>WeakMap</code></strong> 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">MDN</a></p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set" target="_blank" rel="noopener">WeakMap.prototype.set()</a></p><hr><h4 id="解决symbol类型"><a href="#解决symbol类型" class="headerlink" title="解决symbol类型"></a>解决symbol类型</h4><p>1.getOwnPropertySymbols</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(source); <span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span> (symKeys.length) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">    symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isObject(source[symKey])) &#123;</span><br><span class="line">            target[symKey] = cloneDeep(source[symKey], hash); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[symKey] = source[symKey];</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Reflect.ownKeys()</p><p>使用这个方法比较简单，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" target="_blank" rel="noopener">MDN</a>返回一个由<strong>目标对象</strong>自身的属性<strong>键</strong>组成的<strong>数组</strong>。</p><p>可以直接返回symbol的键名</p><blockquote><p>可以通过 <code>toString()</code> 来获取每个对象的类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，传递要检查的对象作为第一个参数，称为 <code>thisArg</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">&gt; </span><br><span class="line">&gt; toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">&gt; toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">&gt; toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">&gt; toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">&gt; toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>Object.prototype.toString().slice(8,-1)</code>截取掉前面的[object 和 ] 就可以获得数据类型了</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj !== <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source</span><br><span class="line">    <span class="comment">// 如果数据存在 hash表里 函数直接退出返回 hash中的数据 避免死循环</span></span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) &#123;</span><br><span class="line">        <span class="comment">// 返回key关联对象, 或者 undefined(没有key关联对象时)。</span></span><br><span class="line">        <span class="keyword">return</span> hash.get(source) </span><br><span class="line">    &#125;<span class="comment">// 查哈希表</span></span><br><span class="line"><span class="comment">// 判断是对象还是数组</span></span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [...obj] : &#123;...obj&#125;</span><br><span class="line">    hash.set(source, target) <span class="comment">// 哈希表设值</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(newObj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newObj[key] = isObject(obj[key]) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决递归爆栈"><a href="#解决递归爆栈" class="headerlink" title="解决递归爆栈"></a>解决递归爆栈</h3><p>简单实现， 各种边界类型还没实现，只能是对象</p><p><strong>具体思路：</strong> 定义一个树的数据结构：有<code>parent</code>父节点，<code>key</code>键名，<code>data</code>键值。循环遍历树的方式：使用栈，开始循环，从栈中取出一个节点，如果是引用类型，推入栈，如果是普通类型直接赋值。直到栈中没有数据，说明全都遍历完了，可以单步调试去看看效果。因为是递归，所以是反着来的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneLoop</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: <span class="literal">undefined</span>,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span> &amp;&amp; data[k] !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS深浅拷贝&quot;&gt;&lt;a href=&quot;#JS深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;JS深浅拷贝&quot;&gt;&lt;/a&gt;JS深浅拷贝&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;要想深入的确实个值得探究的问题&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;首先明确两个概念&quot;&gt;&lt;a href=&quot;#首先明确两个概念&quot; class=&quot;headerlink&quot; title=&quot;首先明确两个概念&quot;&gt;&lt;/a&gt;首先明确两个概念&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基本数据类型&lt;/strong&gt;：String、Number、Boolean、Null、Undefined、Symbol。基本数据类型是直接存储在栈中的数据。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;引用数据类型&lt;/strong&gt;：Array、Object。引用数据类型在该对象在栈中存储的是&lt;strong&gt;引用地址&lt;/strong&gt;，指向内存堆中真实的数据。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数美科技笔试题</title>
    <link href="http://yoursite.com/2020/01/09/%E6%95%B0%E7%BE%8E%E7%A7%91%E6%8A%80%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2020/01/09/%E6%95%B0%E7%BE%8E%E7%A7%91%E6%8A%80%E7%AC%94%E8%AF%95%E9%A2%98/</id>
    <published>2020-01-09T13:02:36.953Z</published>
    <updated>2020-01-11T04:00:22.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数美科技笔试题"><a href="#数美科技笔试题" class="headerlink" title="数美科技笔试题"></a>数美科技笔试题</h1><table><thead><tr><th>逻辑与，AND（<code>&amp;&amp;</code>）</th><th><code>expr1 &amp;&amp; expr2</code></th><th>若 <code>expr1</code> 可转换为 <code>true</code>，则返回 <code>expr2</code>；否则，返回 <code>expr1</code>。</th></tr></thead><tbody><tr><td>逻辑或，OR（`</td><td></td><td>`）</td></tr></tbody></table><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.val = <span class="number">1</span> <span class="comment">//全局 val 为 1</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">  val: <span class="number">10</span>,</span><br><span class="line">  dbl: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val *= <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">json.dbl() <span class="comment">// json.val 为 20 ，this指向调用对象json</span></span><br><span class="line"><span class="keyword">var</span> dbl = json.dbl</span><br><span class="line">dbl() <span class="comment">// window.val 为 2 ， 赋值传递丢失绑定对象 this指向全局</span></span><br><span class="line">json.dbl.call(<span class="built_in">window</span>) <span class="comment">// window.val 为 4 ，ceindwall使this指向 window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.val + json.val) <span class="comment">// 4 + 20 = 24</span></span><br></pre></td></tr></table></figure><hr><h3 id="JS执行顺序问题"><a href="#JS执行顺序问题" class="headerlink" title="JS执行顺序问题"></a>JS执行顺序问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Shumei'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'SM'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">JS编译过程是这样的：</span><br><span class="line">先是声明变量不赋值 <span class="keyword">var</span> name;</span><br><span class="line">然后执行自执行函数 </span><br><span class="line">再name = <span class="string">'shumei'</span></span><br><span class="line"></span><br><span class="line">所以函数执行的时候 变量只声明 但是未赋值</span><br><span class="line">输出： helloSM</span><br></pre></td></tr></table></figure><hr><h3 id="数据类型原理问题"><a href="#数据类型原理问题" class="headerlink" title="数据类型原理问题"></a>数据类型原理问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> a2 = a1</span><br><span class="line">a1[<span class="number">0</span>] = a2[<span class="number">1</span>]</span><br><span class="line">a2.push(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1)</span><br><span class="line"><span class="built_in">console</span>.log(a2)</span><br><span class="line"></span><br><span class="line">数组是引用数据类型，引用数据类型在该对象在栈中存储的是引用地址，指向内存堆中真实的数据。</span><br><span class="line">所以说如果是引用类型数据的新赋值，会影响到原数据。</span><br><span class="line">输出：</span><br><span class="line">[ <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">[ <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br></pre></td></tr></table></figure><hr><h3 id="JS继承问题"><a href="#JS继承问题" class="headerlink" title="JS继承问题"></a>JS继承问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">if</span>(age != <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype = &#123;</span><br><span class="line">    name: <span class="string">'SM'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name); <span class="comment">// undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);  <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.constructor);  <span class="comment">// [Function: object]</span></span><br></pre></td></tr></table></figure><hr><h3 id="双等转化问题"><a href="#双等转化问题" class="headerlink" title="双等转化问题"></a>双等转化问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"false"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log([] == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false </span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><h3 id="JS异步同步问题"><a href="#JS异步同步问题" class="headerlink" title="JS异步同步问题"></a>JS异步同步问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; <span class="comment">// 这里不是逗号</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  i == <span class="number">1</span> &amp;&amp; resolve(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>答案及解释：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">涉及异步同步，宏任务微任务</span><br><span class="line">先执行JS引擎线程全局宏任务 输出 <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line">然后执行 清空微任务 then 后的 输出 <span class="number">4</span> </span><br><span class="line">再执行宏任务 定时器线程执行完 然后回调到事件队列 输出 <span class="number">1</span> </span><br><span class="line">输出：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数美科技笔试题&quot;&gt;&lt;a href=&quot;#数美科技笔试题&quot; class=&quot;headerlink&quot; title=&quot;数美科技笔试题&quot;&gt;&lt;/a&gt;数美科技笔试题&lt;/h1&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;逻辑与，AND（&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;）&lt;/th&gt;&lt;th&gt;&lt;code&gt;expr1 &amp;amp;&amp;amp; expr2&lt;/code&gt;&lt;/th&gt;&lt;th&gt;若 &lt;code&gt;expr1&lt;/code&gt; 可转换为 &lt;code&gt;true&lt;/code&gt;，则返回 &lt;code&gt;expr2&lt;/code&gt;；否则，返回 &lt;code&gt;expr1&lt;/code&gt;。&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;逻辑或，OR（`&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;`）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavsScript错题</title>
    <link href="http://yoursite.com/2020/01/03/Javascript%E9%94%99%E9%A2%98/"/>
    <id>http://yoursite.com/2020/01/03/Javascript%E9%94%99%E9%A2%98/</id>
    <published>2020-01-03T06:40:17.822Z</published>
    <updated>2020-01-03T07:29:31.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javscript题目"><a href="#Javscript题目" class="headerlink" title="Javscript题目"></a>Javscript题目</h1><blockquote><p>错题记录，有些题目懵逼</p></blockquote><h6 id="哪个选项是不正确的"><a href="#哪个选项是不正确的" class="headerlink" title="哪个选项是不正确的?"></a>哪个选项是不正确的?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;</span><br><span class="line">  size: <span class="string">"small"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouse = &#123;</span><br><span class="line">  name: <span class="string">"Mickey"</span>,</span><br><span class="line">  small: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><ul><li>A: <code>mouse.bird.size</code></li><li>B: <code>mouse[bird.size]</code></li><li>C: <code>mouse[bird[&quot;size&quot;]]</code></li><li>D: All of them are valid</li></ul><h4 id="答案-A"><a href="#答案-A" class="headerlink" title="答案: A"></a>答案: A</h4><p>在<code>JavaScript</code>中，所有对象键都是字符串（除了<code>Symbol</code>）。尽管有时我们可能不会给定字符串类型，但它们总是被转换为字符串。</p><p><code>JavaScript</code>解释语句。当我们使用方括号表示法时，它会看到第一个左括号<code>[</code>，然后继续，直到找到右括号<code>]</code>。只有在那个时候，它才会对这个语句求值。</p><p><code>mouse [bird.size]</code>：首先它会对<code>bird.size</code>求值，得到<code>small</code>。 <code>mouse [“small”]</code>返回<code>true</code>。</p><p>但是，使用点表示法，这不会发生。 <code>mouse</code>没有名为<code>bird</code>的键，这意味着<code>mouse.bird</code>是<code>undefined</code>。然后，我们使用点符号来询问<code>size</code>：<code>mouse.bird.size</code>。由于<code>mouse.bird</code>是<code>undefined</code>，我们实际上是在询问<code>undefined.size</code>。这是无效的，并将抛出<code>Cannot read property &quot;size&quot; of undefined</code>。</p><hr><h6 id="下面代码的输出是什么"><a href="#下面代码的输出是什么" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> colorChange(newColor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(&#123; newColor = <span class="string">"green"</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">"purple"</span> &#125;);</span><br><span class="line">freddie.colorChange(<span class="string">"orange"</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>orange</code></li><li>B: <code>purple</code></li><li>C: <code>green</code></li><li>D: <code>TypeError</code></li></ul><h4 id="答案-D"><a href="#答案-D" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>colorChange</code>方法是静态的。静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。由于<code>freddie</code>是一个子级对象，函数不会传递，所以在<code>freddie</code>实例上不存在<code>freddie</code>方法：抛出<code>TypeError</code>。</p><hr><h6 id="下面代码的输出是什么-1"><a href="#下面代码的输出是什么-1" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">"Lydia"</span>, <span class="string">"Hallie"</span>);</span><br><span class="line">Person.getFullName = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure><ul><li>A: <code>TypeError</code></li><li>B: <code>SyntaxError</code></li><li>C: <code>Lydia Hallie</code></li><li>D: <code>undefined</code> <code>undefined</code></li></ul><h4 id="答案-A-1"><a href="#答案-A-1" class="headerlink" title="答案: A"></a>答案: A</h4><p>您不能像使用常规对象那样向构造函数添加属性。如果要一次向所有对象添加功能，则必须使用原型。所以在这种情况下应该这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会使<code>member.getFullName()</code>是可用的，为什么样做是对的？假设我们将此方法添加到构造函数本身。也许不是每个<code>Person</code>实例都需要这种方法。这会浪费大量内存空间，因为它们仍然具有该属性，这占用了每个实例的内存空间。相反，如果我们只将它添加到原型中，我们只需将它放在内存中的一个位置，但它们都可以访问它！</p><hr><h6 id="下面代码的输出是什么-2"><a href="#下面代码的输出是什么-2" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lydia = <span class="keyword">new</span> Person(<span class="string">"Lydia"</span>, <span class="string">"Hallie"</span>);</span><br><span class="line"><span class="keyword">const</span> sarah = Person(<span class="string">"Sarah"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lydia);</span><br><span class="line"><span class="built_in">console</span>.log(sarah);</span><br></pre></td></tr></table></figure><ul><li>A: <code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>undefined</code></li><li>B: <code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>Person {firstName: &quot;Sarah&quot;, lastName: &quot;Smith&quot;}</code></li><li>C: <code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>{}</code></li><li>D:<code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>ReferenceError</code></li></ul><h4 id="答案-A-2"><a href="#答案-A-2" class="headerlink" title="答案: A"></a>答案: A</h4><p>对于<code>sarah</code>，我们没有使用<code>new</code>关键字。使用<code>new</code>时，它指的是我们创建的新空对象。但是，如果你不添加<code>new</code>它指的是全局对象！</p><p>我们指定了<code>this.firstName</code>等于<code>&#39;Sarah</code>和<code>this.lastName</code>等于<code>Smith</code>。我们实际做的是定义<code>global.firstName =&#39;Sarah&#39;</code>和<code>global.lastName =&#39;Smith</code>。 <code>sarah</code>本身的返回值是<code>undefined</code>。</p><hr><h6 id="下面代码的输出是什么-3"><a href="#下面代码的输出是什么-3" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonInfo</span>(<span class="params">one, two, three</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(one);</span><br><span class="line">  <span class="built_in">console</span>.log(two);</span><br><span class="line">  <span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">"Lydia"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">getPersonInfo<span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure><ul><li>A: <code>Lydia</code> <code>21</code> <code>[&quot;&quot;, &quot;is&quot;, &quot;years old&quot;]</code></li><li>B: <code>[&quot;&quot;, &quot;is&quot;, &quot;years old&quot;]</code> <code>Lydia</code> <code>21</code></li><li>C: <code>Lydia</code> <code>[&quot;&quot;, &quot;is&quot;, &quot;years old&quot;]</code> <code>21</code></li></ul><h4 id="答案-B"><a href="#答案-B" class="headerlink" title="答案: B"></a>答案: B</h4><p>如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。其余参数获取传递到模板字符串中的表达式的值！</p><hr><h6 id="下面代码的输出是什么-4"><a href="#下面代码的输出是什么-4" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data === &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"You are an adult!"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"You are still an adult."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hmm.. You don't have an age I guess`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAge(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>A: <code>You are an adult!</code></li><li>B: <code>You are still an adult.</code></li><li>C: <code>Hmm.. You don&#39;t have an age I guess</code></li></ul><h4 id="答案-C"><a href="#答案-C" class="headerlink" title="答案: C"></a>答案: C</h4><p>在比较相等性，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。<code>JavaScript</code>检查对象是否具有对内存中相同位置的引用。</p><p>我们作为参数传递的对象和我们用于检查相等性的对象在内存中位于不同位置，所以它们的引用是不同的。</p><p>这就是为什么<code>{ age: 18 } === { age: 18 }</code>和 <code>{ age: 18 } == { age: 18 }</code> 返回 <code>false</code>的原因。</p><hr><h6 id="下面代码的输出是什么-5"><a href="#下面代码的输出是什么-5" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;array&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;NaN&quot;</code></li></ul><h4 id="答案-C-1"><a href="#答案-C-1" class="headerlink" title="答案: C"></a>答案: C</h4><p>扩展运算符（<code>... args</code>）返回一个带参数的数组。数组是一个对象，因此<code>typeof args</code>返回<code>object</code>。</p><hr><h6 id="下面代码的输出是什么-6"><a href="#下面代码的输出是什么-6" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">"10*10+5"</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>105</code></li><li>B: <code>&quot;105&quot;</code></li><li>C: <code>TypeError</code></li><li>D: <code>&quot;10*10+5&quot;</code></li></ul><h4 id="答案-A-3"><a href="#答案-A-3" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>eval</code>会为字符串传递的代码求值。如果它是一个表达式，就像在这种情况下一样，它会计算表达式。表达式为<code>10 * 10 + 5</code>计算得到<code>105</code>。</p><hr><h6 id="下面代码的输出是什么-7"><a href="#下面代码的输出是什么-7" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><ul><li>A: <code>8</code></li><li>B: <code>10</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>ReferenceError</code></li></ul><h4 id="答案-B-1"><a href="#答案-B-1" class="headerlink" title="答案: B"></a>答案: B</h4><p>使用<code>var</code>关键字，您可以用相同的名称<strong>声明多个变量</strong>。然后变量将保存最新的值。</p><p>您不能使用<code>let</code>或<code>const</code>来实现这一点，因为它们是块作用域的。</p><hr><h6 id="下面代码的输出是什么-8"><a href="#下面代码的输出是什么-8" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5]);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty("1");</span><br><span class="line">obj.hasOwnProperty(1);</span><br><span class="line"><span class="keyword">set</span>.has("1");</span><br><span class="line"><span class="keyword">set</span>.has(1);</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code> <code>true</code> <code>false</code> <code>true</code></li><li>B: <code>false</code> <code>true</code> <code>true</code> <code>true</code></li><li>C: <code>true</code> <code>true</code> <code>false</code> <code>true</code></li><li>D: <code>true</code> <code>true</code> <code>true</code> <code>true</code></li></ul><h4 id="答案-C-2"><a href="#答案-C-2" class="headerlink" title="答案: C"></a>答案: C</h4><p><strong>所有对象键（不包括<code>Symbols</code>）都会被存储为字符串</strong>，即使你没有给定字符串类型的键。这就是为什么<code>obj.hasOwnProperty（&#39;1&#39;）</code>也返回<code>true</code>。</p><p>上面的说法不适用于<code>Set</code>。在我们的<code>Set</code>中没有<code>“1”</code>：<code>set.has（&#39;1&#39;）</code>返回<code>false</code>。它有数字类型<code>1</code>，<code>set.has（1）</code>返回<code>true</code>。</p><hr><h6 id="下面代码的输出是什么-9"><a href="#下面代码的输出是什么-9" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">"one"</span>, <span class="attr">b</span>: <span class="string">"two"</span>, <span class="attr">a</span>: <span class="string">"three"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><ul><li>A: <code>{ a: &quot;one&quot;, b: &quot;two&quot; }</code></li><li>B: <code>{ b: &quot;two&quot;, a: &quot;three&quot; }</code></li><li>C: <code>{ a: &quot;three&quot;, b: &quot;two&quot; }</code></li><li>D: <code>SyntaxError</code></li></ul><h4 id="答案-C-3"><a href="#答案-C-3" class="headerlink" title="答案: C"></a>答案: C</h4><p>如果对象有<strong>两个具有相同名称的键</strong>，则将<strong>替前面的键</strong>。它仍将处于第一个位置，但具有最后指定的值。</p><hr><h6 id="下面代码的输出是什么-10"><a href="#下面代码的输出是什么-10" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">"b"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span>;</span><br><span class="line">a[c] = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure><ul><li>A: <code>123</code></li><li>B: <code>456</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><h4 id="答案-B-2"><a href="#答案-B-2" class="headerlink" title="答案: B"></a>答案: B</h4><p>对象键自动转换为字符串。我们试图将一个对象设置为对象<code>a</code>的键，其值为<code>123</code>。</p><p>但是，当对象自动转换为字符串化时，它变成了<code>[Object object]</code>。所以我们在这里说的是<code>a[&quot;Object object&quot;] = 123</code>。然后，我们可以尝试再次做同样的事情。 <code>c</code>对象同样会发生隐式类型转换。那么，<code>a[&quot;Object object&quot;] = 456</code>。</p><p>然后，我们打印<code>a[b]</code>，它实际上是<code>a[&quot;Object object&quot;]</code>。我们将其设置为<code>456</code>，因此返回<code>456</code>。</p><hr><h6 id="下面代码的输出是什么-11"><a href="#下面代码的输出是什么-11" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;string&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;undefined&quot;</code></li></ul><h4 id="答案-B-3"><a href="#答案-B-3" class="headerlink" title="答案: B"></a>答案: B</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof 1` 返回 `&quot;number&quot;`.</span><br><span class="line">`typeof &quot;number&quot;` 返回 `&quot;string&quot;</span><br></pre></td></tr></table></figure><hr><h6 id="下面代码的输出是什么-12"><a href="#下面代码的输出是什么-12" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">numbers[<span class="number">10</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[1, 2, 3, 7 x null, 11]</code></li><li>B: <code>[1, 2, 3, 11]</code></li><li>C: <code>[1, 2, 3, 7 x empty, 11]</code></li><li>D: <code>SyntaxError</code></li></ul><h4 id="答案-C-4"><a href="#答案-C-4" class="headerlink" title="答案: C"></a>答案: C</h4><p>When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called “empty slots”. These actually have the value of <code>undefined</code>, but you will see something like:</p><p>当你为数组中的元素设置一个超过数组长度的值时，<code>JavaScript</code>会创建一个名为“空插槽”的东西。这些位置的值实际上是<code>undefined</code>，但你会看到类似的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 7 x empty, 11]</span><br></pre></td></tr></table></figure><p>这取决于你运行它的位置（每个浏览器有可能不同）。</p><hr><h6 id="下面代码的输出是什么-13"><a href="#下面代码的输出是什么-13" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x, y;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    (x = <span class="number">1</span>), (y = <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>undefined</code> <code>2</code></li><li>B: <code>undefined</code> <code>undefined</code> <code>undefined</code></li><li>C: <code>1</code> <code>1</code> <code>2</code></li><li>D: <code>1</code> <code>undefined</code> <code>undefined</code></li></ul><h4 id="答案-A-4"><a href="#答案-A-4" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>catch</code>块接收参数<code>x</code>。当我们传递参数时，这与变量的<code>x</code>不同。这个变量<code>x</code>是属于<code>catch</code>作用域的。</p><p>之后，我们将这个块级作用域的变量设置为<code>1</code>，并设置变量<code>y</code>的值。现在，我们打印块级作用域的变量<code>x</code>，它等于<code>1</code>。</p><p>在<code>catch</code>块之外，<code>x</code>仍然是<code>undefined</code>，而<code>y</code>是<code>2</code>。当我们想在<code>catch</code>块之外的<code>console.log(x)</code>时，它返回<code>undefined</code>，而<code>y</code>返回<code>2</code>。</p><hr><p><code>JavaScript</code>只有原始类型和对象。</p><hr><h6 id="下面代码的输出是什么-14"><a href="#下面代码的输出是什么-14" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]].reduce(</span><br><span class="line">  (acc, cur) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[0, 1, 2, 3, 1, 2]</code></li><li>B: <code>[6, 1, 2]</code></li><li>C: <code>[1, 2, 0, 1, 2, 3]</code></li><li>D: <code>[1, 2, 6]</code></li></ul><h4 id="答案-C-5"><a href="#答案-C-5" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>[1,2]</code>是我们的初始值。这是我们开始执行<code>reduce</code>函数的初始值，以及第一个<code>acc</code>的值。在第一轮中，<code>acc</code>是<code>[1,2]</code>，<code>cur</code>是<code>[0,1]</code>。我们将它们连接起来，结果是<code>[1,2,0,1]</code>。</p><p>然后，<code>acc</code>的值为<code>[1,2,0,1]</code>，<code>cur</code>的值为<code>[2,3]</code>。我们将它们连接起来，得到<code>[1,2,0,1,2,3]</code>。</p><hr><h6 id="setInterval方法的返回值什么"><a href="#setInterval方法的返回值什么" class="headerlink" title="setInterval方法的返回值什么?"></a><code>setInterval</code>方法的返回值什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Hi"</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ul><li>A：一个唯一的<code>id</code></li><li>B：指定的毫秒数</li><li>C：传递的函数</li><li>D：<code>undefined</code></li></ul><h4 id="答案-A-5"><a href="#答案-A-5" class="headerlink" title="答案: A"></a>答案: A</h4><p>它返回一个唯一的<code>id</code>。此<code>id</code>可用于使用<code>clearInterval()</code>函数清除该定时器。</p><hr><h6 id="What-does-this-return"><a href="#What-does-this-return" class="headerlink" title="What does this return?"></a>What does this return?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">"Lydia"</span>];</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]</code></li><li>B: <code>[&quot;Lydia&quot;]</code></li><li>C: <code>[[], &quot;Lydia&quot;]</code></li><li>D: <code>[[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]]</code></li></ul><h4 id="答案-A-6"><a href="#答案-A-6" class="headerlink" title="答案: A"></a>答案: A</h4><p>字符串是可迭代的。扩展运算符将迭代的每个字符映射到一个元素。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Javscript题目&quot;&gt;&lt;a href=&quot;#Javscript题目&quot; class=&quot;headerlink&quot; title=&quot;Javscript题目&quot;&gt;&lt;/a&gt;Javscript题目&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;错题记录，有些题目懵逼&lt;/p&gt;&lt;/blockquote&gt;&lt;h6 id=&quot;哪个选项是不正确的&quot;&gt;&lt;a href=&quot;#哪个选项是不正确的&quot; class=&quot;headerlink&quot; title=&quot;哪个选项是不正确的?&quot;&gt;&lt;/a&gt;哪个选项是不正确的?&lt;/h6&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; bird = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  size: &lt;span class=&quot;string&quot;&gt;&quot;small&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; mouse = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&quot;Mickey&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  small: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2020都来了，TypeScript还不快学习一下</title>
    <link href="http://yoursite.com/2020/01/02/2020%E9%83%BD%E6%9D%A5%E4%BA%86%EF%BC%8CTypeScript%E8%BF%98%E4%B8%8D%E5%BF%AB%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B/"/>
    <id>http://yoursite.com/2020/01/02/2020%E9%83%BD%E6%9D%A5%E4%BA%86%EF%BC%8CTypeScript%E8%BF%98%E4%B8%8D%E5%BF%AB%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B/</id>
    <published>2020-01-02T11:43:26.514Z</published>
    <updated>2020-01-02T12:44:20.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript学习笔记（一）（基础部分）"><a href="#TypeScript学习笔记（一）（基础部分）" class="headerlink" title="TypeScript学习笔记（一）（基础部分）"></a>TypeScript学习笔记（一）（基础部分）</h1><blockquote><p>预言：为什么学习TypeScript？</p><p>VUE3也使用了TS，现在三大框架都转为TypeScript，Node无力回天，Deno前景明朗，使用V8引擎解析TS。</p><p>TS遍地开花，大势所趋。2020肯定迟早都要学的，不如早点儿赶上潮流（😥其实不算早了）</p><p>它是javascript的超集，有静态类型检查，清晰函数参数，接口属性，增加了代码的可读性。</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>入门学习推荐：</p><p><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程文档</a></p><p><a href="https://jspang.com/detailed?id=38" target="_blank" rel="noopener">技术胖ts视频教程</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>TypeScript 的命令行工具安装全局：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g typescript</span><br></pre></td></tr></table></figure><h3 id="helloWorld"><a href="#helloWorld" class="headerlink" title="helloWorld"></a>helloWorld</h3><p>创建文件hello.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`hello,  <span class="subst">$&#123;person&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'Jason'</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user))</span><br></pre></td></tr></table></figure><p>终端输入：<code>tsc hello.ts</code></p><p>编译完后，出现文件hello.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello,  "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">'Jason'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="boolean（布尔值）"><a href="#boolean（布尔值）" class="headerlink" title="boolean（布尔值）"></a>boolean（布尔值）</h3><p>使用 <code>boolean</code> 定义布尔值类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br></pre></td></tr></table></figure><p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: boolean = new Boolean(1);</span><br></pre></td></tr></table></figure><p><code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。</p><h3 id="number（数值）"><a href="#number（数值）" class="headerlink" title="number（数值）"></a>number（数值）</h3><p>使用 <code>number</code> 定义数值类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">// 二进制</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">// 八进制</span><br><span class="line">let octalLiteral: number = 0o744;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var decLiteral = 6;</span><br><span class="line">var hexLiteral = 0xf00d;</span><br><span class="line">var binaryLiteral = 10;</span><br><span class="line">var octalLiteral = 484;</span><br></pre></td></tr></table></figure><p>二进制和八进制，它们会被编译为十进制数字。</p><blockquote><p>为什么<code>tsc</code>不转十六进制？</p><p>十和十六进制本身就有，二和八进制是ES6引入的，tsc默认转为ES5，<code>tsc -t ES6 hello.ts</code>转es6就不会改变</p></blockquote><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/TypeScript/image-20200101172413290.png" alt="image-20200101172413290"></p><h3 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h3><p>使用 <code>string</code> 定义字符串类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">'Jason'</span>;</span><br><span class="line"><span class="keyword">let</span> myAge: <span class="built_in">number</span> = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.I'll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>使用 <code>void</code> 表示没有任何返回值的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'My name is Jason'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><code>undefined</code> 和 <code>null</code> 是所有类型的子类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样不会报错</span><br><span class="line">let num: number = undefined;</span><br></pre></td></tr></table></figure><hr><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p><code>any</code> 类型，允许被赋值为任意类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p><p><strong>如果申明 变量 未申明 类型 和 值，那么它会被识别为任意值类型</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something; </span><br><span class="line"><span class="comment">//等价于 let something: any;</span></span><br></pre></td></tr></table></figure><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="comment">// 等价于 let myFavoriteNumber: string = 'seven';</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// 再定义数字类型就会出错 index.ts(2,1): error TS2322: Type 'number' is not assignable</span></span><br></pre></td></tr></table></figure><p><strong>如果申明 ‘变量’ 未申明 ‘类型’ 单定义 ‘值’ ，那么它会自动推测类型</strong>：</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。</p><p><strong>例子</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>TypeScript <strong>不确定</strong>一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里<strong>共有</strong>的属性或方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 length不是 string 和 number 共有属性</span></span><br></pre></td></tr></table></figure><p>联合类型变量被赋值之后，就可以使用其类型方法</p><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>可用于对类的一部分行为进行<strong>抽象</strong>以外，也常用于对「对象的<strong>形状</strong>（Shape）」进行描述</p><p><strong>例子</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="comment">// 只读属性，只能在第一次给 ‘对象’ 创建的时候 赋值</span></span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// 可选属性，该属性可以不存在</span></span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// 任意属性，确定属性 和 可选属性 的类型都必须是其类型的子集</span></span><br><span class="line">    <span class="comment">//[propName: string]: string; 报错，age?: number;不是string的子集</span></span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义变量jason，约束jason的形状必须和Person接口一致，接口首字母大写或I开头</span></span><br><span class="line"><span class="keyword">let</span> jason: Person = &#123;</span><br><span class="line">    id: <span class="number">19040108</span></span><br><span class="line">    name: <span class="string">'Jason</span></span><br><span class="line"><span class="string">    age: 20</span></span><br><span class="line"><span class="string">    //任意属性下的结果</span></span><br><span class="line"><span class="string">    gender: '</span>male<span class="string">'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">jason.id = 19040101; //报错，只读属性不能再次赋值</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>只读属性</strong>只能在第一次给 <strong>‘对象’ 创建</strong>的时候 赋值，不能在外面单独赋值</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/TypeScript/image-20200102105140825.png" alt="image-20200102105140825"></p><hr><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><h4 id="「类型-方括号」表示法"><a href="#「类型-方括号」表示法" class="headerlink" title="「类型 + 方括号」表示法"></a>「类型 + 方括号」表示法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// let fibonacci: number[] = [1, '1', 2, 3, 5]; //出现string报错</span></span><br><span class="line"><span class="comment">// fibonacci.push('8'); 报错，推入string也不行</span></span><br></pre></td></tr></table></figure><h4 id="数组泛型-表示法"><a href="#数组泛型-表示法" class="headerlink" title="数组泛型 表示法"></a>数组泛型 表示法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h4 id="接口-表示法"><a href="#接口-表示法" class="headerlink" title="接口 表示法"></a>接口 表示法</h4><p>常用来表示<strong>类数组</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">    <span class="comment">// 只要索引的类型是数字时，那么值的类型必须是数字</span></span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IArguments &#123;</span><br><span class="line"><span class="comment">// 约束当 索引 的类型是数字时，值的类型是任意类型</span></span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">    <span class="comment">// 约束它有length 和callee两个属性</span></span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    callee: <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p><strong>函数声明</strong>的类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);<span class="comment">// 报错，输入了过少的参数</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">// 报错，输入了过多的参数</span></span><br></pre></td></tr></table></figure><p><strong>数表达式</strong>的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (x: type,...输入类型) =&gt; 输出类型 ，不要和箭头函数混淆了</span></span><br><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状:"></a>用接口定义函数的形状:</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后面 = 赋值默认参数，同 es6语法</span></span><br><span class="line"><span class="comment">// 用 `?` 表示可选的参数：,可选参数 必须接在 必需参数 后面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = 'unkownName', lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Jason'</span>, <span class="string">'Wu'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Jason'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数，语法同es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>用重载定义多个 <code>reverse</code> 的函数类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精确表达，输入为数字的时候，输出也应该为数字</span></span><br><span class="line"><span class="comment">// 优先把精确的定义写在前面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="comment">// 输入为字符串的时候，输出也应该为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><blockquote><p>当使用 type1 | type2 这种情况，类型还不确定的时候，TS只会有其<strong>共有方法</strong>，获取单独属性方法就会报错， 手动断言指定一个值的类型。</p></blockquote><p>需要断言的变量前加上<type>即可</type></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if ((something).length) 报错，只有其共有方法</span></span><br><span class="line">    <span class="comment">// 将 `something` 断言成 `string` </span></span><br><span class="line">    <span class="comment">// 联合类型中不存在的类型不允许断言 eg：&lt;boolean&gt;something</span></span><br><span class="line">    <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;something).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;<span class="built_in">string</span>&gt;something).length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><blockquote><p>声明语句：定义了全局变量的类型，仅仅会用于编译时的检查，在编译结果中会被删除。</p><p>把声明语句放到一个单独的文件（<code>file.d.ts</code>）中，以 <code>.d.ts</code> 结尾的文件就是声明文件。</p><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。</p></blockquote><p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="declare-var"><a href="#declare-var" class="headerlink" title="declare var"></a><code>declare var</code></h4><p>用来定义<strong>全局变量</strong>的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="comment">// 注入全局变量jQuery ，declare 只能用来声明类型,不能用来赋值</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line"><span class="comment">// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量</span></span><br><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="declare-function"><a href="#declare-function" class="headerlink" title="declare function"></a><code>declare function</code></h4><p>用来定义<strong>全局函数</strong>的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="comment">// 可以函数重载</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">domReadyCallback: () =&gt; <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Dom Ready!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="declare-class"><a href="#declare-class" class="headerlink" title="declare class"></a><code>declare class</code></h4><p>定义<strong>全局 类</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Animal.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Person &#123;    </span><br><span class="line">    name: <span class="built_in">string</span>;    </span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);    </span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// declare里 只能用来定义类型，不能用来具体实现</span></span><br><span class="line">    <span class="comment">// sayHi() &#123; //报错</span></span><br><span class="line">    <span class="comment">//    return `My name is $&#123;this.name&#125;`;</span></span><br><span class="line">    <span class="comment">// &#125;; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'Jason'</span>);</span><br></pre></td></tr></table></figure><h4 id="declare-enum"><a href="#declare-enum" class="headerlink" title="declare enum"></a><code>declare enum</code></h4><p>使用 <code>declare enum</code> 定义的枚举类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Directions.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;    </span><br><span class="line">    Up,    </span><br><span class="line">    Down,    </span><br><span class="line">    Left,    </span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><h4 id="declare-namespace"><a href="#declare-namespace" class="headerlink" title="declare namespace"></a><code>declare namespace</code></h4><p>用来表示全局变量是一个对象，包含很多子属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="comment">// namespace内部可以直接使用function xxx，不必declare function xxx</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="keyword">const</span> version: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">class</span> Event &#123;</span><br><span class="line">        blur(eventType: EventType): <span class="built_in">void</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> EventType &#123;</span><br><span class="line">        CustomClick</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 嵌套命名空间，声明深层对象属性， 但是仅有一个深层属性就可以不写namespace</span></span><br><span class="line">    <span class="keyword">namespace</span> fn &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">object: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jQuery.version);</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> jQuery.Event();</span><br><span class="line">e.blur(jQuery.EventType.CustomClick);</span><br><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    check: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.checked = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a><code>interface</code></h3><p>在类型声明文件中，可以直接使用 <code>interface</code> 来声明一个全局的接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> AjaxSettings &#123;    </span><br><span class="line">    method?: <span class="string">'GET'</span> | <span class="string">'POST'</span>    </span><br><span class="line">    data?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: AjaxSettings</span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="comment">// 接口和类型，最好还是放在namespace下,减少全局变量</span></span><br><span class="line">     <span class="keyword">interface</span> AjaxSettings &#123;</span><br><span class="line">        method?: <span class="string">'GET'</span> | <span class="string">'POST'</span></span><br><span class="line">        data?: <span class="built_in">any</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，在其他文件中也可以使用这个接口或类型了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">let</span> settings: AjaxSettings = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>, </span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.ajax(<span class="string">'/api/post_something'</span>, settings);</span><br><span class="line"><span class="comment">// 在命名空间里声明的接口 加上前缀 namespaceName.interfaceName...</span></span><br><span class="line"><span class="keyword">let</span> settings: jQuery.AjaxSettings = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h4><p>可以组合多个声明语句，它们不冲突</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br></pre></td></tr></table></figure><h3 id="npm包"><a href="#npm包" class="headerlink" title="npm包"></a>npm包</h3><p>判断声明文件是否已经存在。</p><ol><li><code>package.json</code>中有<code>types</code>字段，或有一个<code>index.d.ts</code>声明文件（推荐）。</li><li>发布到<code>@types</code>里，安装试一下有无 <code>cnpm i @types/foo --save-dev</code>作者没有发布，一般由其他人补充。</li></ol><p>如果以上两种方法都没有，就只能自己创建</p><p>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</p><p>目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/to/project</span><br><span class="line">├── src</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── types</span><br><span class="line">|  └── foo</span><br><span class="line">|     └── index.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p><code>tsconfig.json</code> 内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="attr">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">        <span class="attr">"paths"</span>: &#123;</span><br><span class="line">            <span class="attr">"*"</span>: [<span class="string">"types/*"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p><h4 id="export"><a href="#export" class="headerlink" title="export"></a><code>export</code></h4><p>只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left, </span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Options &#123;</span><br><span class="line">    data: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个拥有子属性的对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">namespace</span> bar &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 declare声明，再一并导出</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 接口不需要 declare声明</span></span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">    data: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, getName, Animal, Directions, Options &#125;;</span><br></pre></td></tr></table></figure><p>对应的导入和使用模块应该是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    getName,</span><br><span class="line">    Animal,</span><br><span class="line">    Directions,</span><br><span class="line">    Options &#125;</span><br><span class="line"><span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="keyword">let</span> myName = getName();</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line"><span class="keyword">let</span> options: Options = &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line">foo.bar.baz();</span><br></pre></td></tr></table></figure><h3 id="UMD-库"><a href="#UMD-库" class="headerlink" title="UMD 库"></a>UMD 库</h3><p>既可以通过 <code>&lt;script&gt;</code>标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="comment">// 使用 export as namespace xxx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo; <span class="comment">// ES6 标准</span></span><br><span class="line"><span class="comment">// export = foo; ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接扩展全局变量"><a href="#直接扩展全局变量" class="headerlink" title="直接扩展全局变量"></a>直接扩展全局变量</h3><p>扩展 <code>String</code> 类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 `String` 添加属性或方法。</span></span><br><span class="line"><span class="keyword">interface</span> String &#123;</span><br><span class="line">prependHello(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'foo'</span>.prependHello();</span><br></pre></td></tr></table></figure><p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JQuery &#123;</span><br><span class="line">    <span class="keyword">interface</span> CustomOptions &#123;</span><br><span class="line">        bar: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> JQueryStatic &#123;</span><br><span class="line">foo(options: JQuery.CustomOptions): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery.foo(&#123;</span><br><span class="line">bar: <span class="string">''</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="在-npm-包或-UMD-库中扩展全局变量"><a href="#在-npm-包或-UMD-库中扩展全局变量" class="headerlink" title="在 npm 包或 UMD 库中扩展全局变量"></a>在 npm 包或 UMD 库中扩展全局变量</h3><p>对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。如果导入npm 包或 UMD 库之后要扩展全局变量，则需要使用<code>declare global</code>在声明文件中扩展全局变量的类型。</p><h4 id="declare-global"><a href="#declare-global" class="headerlink" title="declare global"></a><code>declare global</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">    <span class="keyword">interface</span> String &#123;        </span><br><span class="line">        prependHello(): <span class="built_in">string</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 告诉编译器这是一个 模块 的声明文件</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="string">'bar'</span>.prependHello();</span><br></pre></td></tr></table></figure><h3 id="模块插件"><a href="#模块插件" class="headerlink" title="模块插件"></a>模块插件</h3><p>原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p><h4 id="declare-module"><a href="#declare-module" class="headerlink" title="declare module"></a><code>declare module</code></h4><p>需要在类型声明文件中<strong>先引用原有模块</strong>，再使用 <code>declare module</code> 扩展原有模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'moment' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">moment</span>.<span class="title">CalendarKey</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在一个文件中 可声明多个模块的类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'bar' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Bar &#123;</span><br><span class="line">        bar: <span class="built_in">string</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment-plugin'</span>;</span><br><span class="line">moment.foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Bar &#125; <span class="keyword">from</span> <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">let</span> B: Bar;</span><br></pre></td></tr></table></figure><h3 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h3><p>应用场景：</p><ul><li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li></ul><blockquote><p>在全局变量的声明文件中，一旦出现了 <code>import</code>, <code>export</code> 关键字。那么他就会被视为一个 npm 包或 UMD 库。写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"><span class="comment">// `///` 后面使用 xml 的格式添加了对 `jquery` 类型的依赖,就可以在声明文件中使用 `JQuery.AjaxSettings` 类型了.</span></span><br><span class="line"><span class="comment">// 三斜线指令必须放在文件的最顶端,除了注释</span></span><br><span class="line"><span class="comment">/// &lt;reference types="jquery" /&gt;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">options: JQuery.AjaxSettings</span>): <span class="title">string</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">foo(&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li></ul><blockquote><p>由于全局变量不支持通过 <code>import</code> 导入，必须使用三斜线指令来引入</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/node-plugin/index.d.ts</span></span><br><span class="line"><span class="comment">// 由于引入的 `node` 中的类型都是全局变量的类型,通过三斜线指引入了 `node` 的类型</span></span><br><span class="line"><span class="comment">/// &lt;reference types="node" /&gt;</span></span><br><span class="line"><span class="comment">// 声明文件中使用了 `NodeJS.Process` 这个类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p: NodeJS.Process</span>): <span class="title">string</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'node-plugin'</span>;</span><br><span class="line"><span class="comment">// 使用到 `foo` 的时候，传入了 `node` 中的全局变量 `process`</span></span><br><span class="line">foo(global.process);</span><br></pre></td></tr></table></figure><h4 id="拆分声明文件"><a href="#拆分声明文件" class="headerlink" title="拆分声明文件"></a>拆分声明文件</h4><blockquote><p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。</p></blockquote><p>比如 <code>jQuery</code> 的声明文件就是这样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/@types/jquery/index.d.ts</span></span><br><span class="line"><span class="comment">// types 用于声明对另一个 '库' 的依赖</span></span><br><span class="line"><span class="comment">/// &lt;reference types="sizzle" /&gt;</span></span><br><span class="line"><span class="comment">// path 用于声明对另一个 '文件' 的依赖</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQueryStatic.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQuery.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="misc.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="legacy.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = jQuery;</span><br></pre></td></tr></table></figure><h3 id="自动生成声明文件"><a href="#自动生成声明文件" class="headerlink" title="自动生成声明文件"></a>自动生成声明文件</h3><p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，命令行添加 <code>--declaration</code>(<code>-d</code>) 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p><p>或者在 <code>tsconfig.json</code> 中添加 <code>declaration: true</code> 选项。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="comment">// `outDir` 选项，将 ts 文件的编译结果输出到 `lib` 目录下</span></span><br><span class="line">        <span class="attr">"outDir"</span>: <span class="string">"lib"</span>,</span><br><span class="line">        <span class="comment">// 将会由 ts 文件自动生成 `.d.ts` 声明文件</span></span><br><span class="line">        <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布声明文件"><a href="#发布声明文件" class="headerlink" title="发布声明文件"></a>发布声明文件</h3><ol><li><p>将声明文件和源码放在一起 (自己写的库)</p><p>需要满足以下条件之一，才能被正确的识别：</p><ul><li><p>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"lib/index.js"</span>,</span><br><span class="line">    "types": "foo.d.ts",...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件</p></li><li><p>如果根目录下没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件，是否存在对应同名不同后缀的 <code>.d.ts</code> 文件</p></li></ul></li><li><p>将声明文件发布到 <code>@types</code> 下（原作者不愿意合并 pull request 时，补充别人的仓库）</p><ul><li>给 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。通过测试，稍后就会被自动发布到 <code>@types</code> 下。</li><li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package" target="_blank" rel="noopener">DefinitelyTyped 文档</a></li></ul></li></ol><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="ECMAScript-的内置对象"><a href="#ECMAScript-的内置对象" class="headerlink" title="ECMAScript 的内置对象"></a>ECMAScript 的内置对象</h3><p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p><p>可以在 TypeScript 中将变量定义为这些类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure><h3 id="DOM-和-BOM-的内置对象"><a href="#DOM-和-BOM-的内置对象" class="headerlink" title="DOM 和 BOM 的内置对象"></a>DOM 和 BOM 的内置对象</h3><p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p><p>TypeScript 中会经常用到这些类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="用-TypeScript-写-Node-js"><a href="#用-TypeScript-写-Node-js" class="headerlink" title="用 TypeScript 写 Node.js"></a>用 TypeScript 写 Node.js</h3><p>TypeScript 核心库的定义中不包含 Node.js 部分，需要引入第三方声明文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>基础部分学完了，总的来说TS可以规范变量，对象，函数类型。声明文件那部分学的不太明白，可能还做过大型库，项目，水平没上来，再多看一些文章加深理解吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TypeScript学习笔记（一）（基础部分）&quot;&gt;&lt;a href=&quot;#TypeScript学习笔记（一）（基础部分）&quot; class=&quot;headerlink&quot; title=&quot;TypeScript学习笔记（一）（基础部分）&quot;&gt;&lt;/a&gt;TypeScript学习笔记（一）（基础部分）&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;预言：为什么学习TypeScript？&lt;/p&gt;&lt;p&gt;VUE3也使用了TS，现在三大框架都转为TypeScript，Node无力回天，Deno前景明朗，使用V8引擎解析TS。&lt;/p&gt;&lt;p&gt;TS遍地开花，大势所趋。2020肯定迟早都要学的，不如早点儿赶上潮流（😥其实不算早了）&lt;/p&gt;&lt;p&gt;它是javascript的超集，有静态类型检查，清晰函数参数，接口属性，增加了代码的可读性。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019年总结</title>
    <link href="http://yoursite.com/2020/01/01/2019%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/01/2019%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-01-02T12:47:29.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019年总结"><a href="#2019年总结" class="headerlink" title="2019年总结"></a>2019年总结</h1><blockquote><p>2019-2020是我奋发前进的一年，有了整体职业方向，前端工程师的路上有坎坷有迷茫。</p></blockquote><p>这一年 因为整天在工作室敲代码，没有陪女朋友，又加上直男言论，无数次分手。万般无奈，因为我知道，我一个二流学校出身的人，我不拼命武装本事，毕业就是失业。</p><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>看到工作室学长春招进了头条我就更加了。仿佛一束光，我觉得我也能行。智力比不过，比勤奋嘛。</p><h3 id="这一年的流水账"><a href="#这一年的流水账" class="headerlink" title="这一年的流水账"></a>这一年的流水账</h3><h4 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h4><p><strong>原生js</strong>写淘宝，学了大几个月的js却不知道怎么用，变量提升啊，轮播图啊，真是开啃荒地一般艰难，完全坚持不下去，想过放弃。</p><h4 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h4><p>开学边学<strong>小程序</strong>边学了<strong>es6</strong>,因为小程序大赛时间紧迫，简单学习，直接就开撸了。写出来的代码不怎么样。但还是费劲心思把基本的功能实现了。最后功亏一篑，没有得奖。</p><h4 id="期末到-暑假"><a href="#期末到-暑假" class="headerlink" title="期末到 暑假"></a>期末到 暑假</h4><p><strong>学习了node</strong> ，整个后台学的比较浅，也是这个时候开始了写博客。对自己所学有所复盘，也可以分享知识。是对自己所学的一个证明吧。</p><h4 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h4><p>下学期学习了<strong>vue</strong>，建好了第一个Vue的脚手架，在云服务器上成功<strong>部署</strong>项目。商城项目前前后后写了快两个月。整体感觉就是从知识模糊到融会贯通。</p><h4 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h4><p>学到一定程度了，想投一个简历试一试，又不敢的心情。一边疯狂查漏补缺，然后投了人生第一个，面试三轮成功。整个流程下来那几天难以入睡。<br>‌<br><strong>深信服的实习工资，给家里买了台松下洗碗机，希望妈妈能解放双手，幸福生活。</strong></p><h4 id="明年计划"><a href="#明年计划" class="headerlink" title="明年计划"></a>明年计划</h4><h4 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h4><p>新的一年，继续健身计划，做好<strong>力量训练</strong>。实习没有运动，感觉肌肉要消失😭</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>需要多一点读书的时间，少刷一点儿手机动态。给自己留一点<strong>独处</strong>的时间<strong>，静下心来，冥想，内省</strong>。</p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>前端学习从零起步到现在，已经把整个前端基础体系过了一遍，接下来还要做好深度和广度。</p><ul><li><p><strong>深度方面:</strong></p><ul><li>继续学习vue源码：我觉得这是最难啃的一部分，从理解原理，vuex，router等组件入手；</li><li>webpack原理，前端工程优化；</li><li>基础算法：还没有做完😥。</li></ul></li><li><p><strong>广度方面 ：</strong></p><ul><li>typescript正在学；</li><li>学习react感觉大公司都在用，不过还是得先把vue给搞透；</li><li>fluter下半年再说吧，现在还不太成熟。</li></ul></li></ul><h3 id="这是个持久战。"><a href="#这是个持久战。" class="headerlink" title="这是个持久战。"></a>这是个持久战。</h3><p>说实话，一路上瞧不起我的人很多，有段时间很无助，我记得高中成绩差，有些人就是鄙视你，找成绩优秀的问问题也不会鸟我。健身刚入门的时候120斤，就有人质疑，“看你健身谈得头头是道，也没有肌肉啊”。</p><p>正是因为总总质疑，各种人的瞧不起，让我不服气，让我奋起直追，要有男儿骨气。老子就是要进大厂，过得体面；就是要浑身肌肉，充满力量。</p><p>还记得王小波说的话：“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。。。我觉得自己会永远生猛下去，什么也锤不了我。”</p><h4 id="重要的是坚持"><a href="#重要的是坚持" class="headerlink" title="重要的是坚持"></a>重要的是坚持</h4><p><strong>默默积累沉淀，输出，希望在2021年进入理想的公司😇</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2019年总结&quot;&gt;&lt;a href=&quot;#2019年总结&quot; class=&quot;headerlink&quot; title=&quot;2019年总结&quot;&gt;&lt;/a&gt;2019年总结&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;2019-2020是我奋发前进的一年，有了整体职业方向，前端工程师的路上有坎坷有迷茫。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这一年 因为整天在工作室敲代码，没有陪女朋友，又加上直男言论，无数次分手。万般无奈，因为我知道，我一个二流学校出身的人，我不拼命武装本事，毕业就是失业。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>socket实现点对点，群通讯</title>
    <link href="http://yoursite.com/2019/12/28/socket%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%8C%E7%BE%A4%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2019/12/28/socket%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%8C%E7%BE%A4%E9%80%9A%E8%AE%AF/</id>
    <published>2019-12-28T03:25:21.071Z</published>
    <updated>2020-01-02T12:39:13.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现socket点对点，群-通讯"><a href="#实现socket点对点，群-通讯" class="headerlink" title="实现socket点对点，群 通讯"></a>实现socket点对点，群 通讯</h1><blockquote><p>Java语言不太熟悉，根据老师的思路，实现了 node websocket的简单通讯，前台用的vue。</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/eg1.png" alt="eg1"></p><h3 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h3><p>当客户端要和服务端建立 WebSocket 连接时，在客户端和服务器的握手过程中，客户端首先会向服务端发送一个 HTTP 请求，包含一个 Upgrade 请求头来告知服务端客户端想要建立一个 WebSocket 连接。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request head:</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade  // 告诉它要升级协议</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Sec-WebSocket-Extensions</span>: permessage-deflate; client_max_window_bits</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: EYW+TeBXX1QDdU5T5/XQ6g==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13  // 协议版本</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket  // 升级到websocket协议</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="简单聊天项目架构"><a href="#简单聊天项目架构" class="headerlink" title="简单聊天项目架构"></a>简单聊天项目架构</h3><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Csocket%E7%AE%80%E5%8D%95%E9%80%9A%E8%AE%AF.png" alt="socket简单通讯"></p><h3 id="用户登陆"><a href="#用户登陆" class="headerlink" title="用户登陆"></a>用户登陆</h3><blockquote><p>由于时间有限，只做了输入用户名登陆</p></blockquote><ol><li>用户输入用户名，客户端生成uid，然后用socket发送给服务端</li></ol><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/LOGIN.png" alt="LOGIN"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听连接成功</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接服务器成功'</span>)</span><br><span class="line">    vm.$message(&#123; <span class="attr">type</span>: <span class="string">'success'</span>, <span class="attr">message</span>: <span class="string">'连接服务器成功'</span> &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!vm.uid) &#123;</span><br><span class="line">        <span class="comment">// moment 为 日期库，通过前缀+时间生成唯一值</span></span><br><span class="line">        vm.uid = <span class="string">'web_tim'</span> + moment().valueOf()</span><br><span class="line">        <span class="comment">// 存在浏览器</span></span><br><span class="line">        localStorage.setItem(</span><br><span class="line">            <span class="string">'WEB_IM_USER'</span>,</span><br><span class="line">            <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                uid: vm.uid,</span><br><span class="line">                nickname: vm.nickname</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向服务端发送1</span></span><br><span class="line">    vm.sendMessage(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>服务端监听。</li></ol><blockquote><p>时间有限，先使用最简单的swich，cash判断客户端发过来的请求，</p><p>暂时使用<strong>数组和对象</strong>保存<strong>数据</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">conn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听客户端发来的消息</span></span><br><span class="line">    conn.on(<span class="string">'text'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj = <span class="built_in">JSON</span>.parse(obj)</span><br><span class="line">        conns[<span class="string">''</span> + obj.uid + <span class="string">''</span>] = conn</span><br><span class="line">        <span class="keyword">switch</span> (obj.type) &#123;</span><br><span class="line">                <span class="comment">// 创建连接</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isUser = users.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.uid === obj.uid</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果没有此用户直接向数组里推，数组里存对象</span></span><br><span class="line"><span class="keyword">if</span> (!isUser) &#123;</span><br><span class="line">    users.push(&#123;</span><br><span class="line">        nickname: obj.nickname,</span><br><span class="line">        uid: obj.uid,</span><br><span class="line">        status: <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  如果有此用户，状态status: 1，为在线 ，status: 0 下线</span></span><br><span class="line">    users.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.uid === obj.uid) &#123;</span><br><span class="line">            item.status = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 广播</span></span><br><span class="line">boardCast(&#123;</span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    msg: obj.nickname + <span class="string">'加入聊天室'</span>,</span><br><span class="line">    users: users,</span><br><span class="line">    groups: groups,</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    bridge: obj.bridge</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h5 id="广播函数"><a href="#广播函数" class="headerlink" title="广播函数"></a>广播函数</h5><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/broadCast.png" alt="broadCast"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boardCast</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 点对点桥接</span></span><br><span class="line">    <span class="keyword">if</span> (obj.bridge &amp;&amp; obj.bridge.length) &#123;</span><br><span class="line">        obj.bridge.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            conns[item].sendText(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 群聊</span></span><br><span class="line">    <span class="keyword">if</span> (obj.groupId) &#123;</span><br><span class="line">        group = groups.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> item.id === obj.groupId</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        group.users.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            conns[item.uid].sendText(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.connections.forEach(<span class="function">(<span class="params">conn, index</span>) =&gt;</span> &#123;</span><br><span class="line">        conn.sendText(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="左侧用户列表与群列表的显示"><a href="#左侧用户列表与群列表的显示" class="headerlink" title="左侧用户列表与群列表的显示"></a>左侧用户列表与群列表的显示</h3><ul><li><strong>用户列表</strong>：简单处理，直接遍历users数组里的用户。有个特殊的，<strong>在线和离线</strong></li></ul><p>动态绑定class属性<code>:class=&quot;{ offline: !item.status }&quot;</code>status上文说过，登陆1，离线0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="selector-class">.offline</span></span><br><span class="line">        <span class="selector-tag">color</span> <span class="selector-id">#ccc</span></span><br></pre></td></tr></table></figure><p>给离线的设个灰度颜色。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/userList.png" alt="userList"></p><ul><li><strong>群列表</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 群数据格式 </span></span><br><span class="line">[&#123;</span><br><span class="line">    <span class="comment">// 群id，通过monent()时间判断</span></span><br><span class="line">    id: moment().valueOf(),</span><br><span class="line">    <span class="comment">// 客户端传过来的群名称</span></span><br><span class="line">    name: obj.groupName,</span><br><span class="line">    <span class="comment">// 群用户可添加多个数组对象</span></span><br><span class="line">    users: [</span><br><span class="line">        &#123;</span><br><span class="line">            uid: obj.uid,</span><br><span class="line">            nickname: obj.nickname</span><br><span class="line">        &#125;,...</span><br><span class="line">    ]</span><br><span class="line">&#125;,...]</span><br></pre></td></tr></table></figure><ol><li><strong>新建群</strong></li></ol><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/newGroup.png" alt="addGroup"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">createGroup () &#123;</span><br><span class="line">    <span class="comment">// 去除前后空格符</span></span><br><span class="line">    <span class="keyword">this</span>.groupName = <span class="keyword">this</span>.groupName.trim()</span><br><span class="line">    <span class="comment">// 确保名称输入</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.groupName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'error'</span>, <span class="attr">message</span>: <span class="string">'请输入群名称'</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用socket连接向服务端发送数据</span></span><br><span class="line">    <span class="keyword">this</span>.socket.send(</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            uid: <span class="keyword">this</span>.uid,</span><br><span class="line">            type: <span class="number">10</span>,</span><br><span class="line">            nickname: <span class="keyword">this</span>.nickname,</span><br><span class="line">            groupName: <span class="keyword">this</span>.groupName,</span><br><span class="line">            bridge: []</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端接受创建群信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建群</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="comment">// 推入群数组</span></span><br><span class="line">groups.push(&#123;</span><br><span class="line">    <span class="comment">// 群id，通过monent()时间判断</span></span><br><span class="line">    id: moment().valueOf(),</span><br><span class="line">    <span class="comment">// 客户端传过来的群名称</span></span><br><span class="line">    name: obj.groupName,</span><br><span class="line">    users: [</span><br><span class="line">        &#123;</span><br><span class="line">            uid: obj.uid,</span><br><span class="line">            nickname: obj.nickname</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">boardCast(&#123;</span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    msg: obj.nickname + <span class="string">'创建了群'</span> + obj.groupName,</span><br><span class="line">    users: users,</span><br><span class="line">    groups: groups,</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    bridge: obj.bridge</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>加入群</strong></li></ol><p>客户端</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/addGroup2.png" alt="addGroup2"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">addGroup (item) &#123;</span><br><span class="line">    <span class="comment">// 通过socket向服务端发送信息</span></span><br><span class="line">    <span class="keyword">this</span>.socket.send(</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            uid: <span class="keyword">this</span>.uid,</span><br><span class="line">            type: <span class="number">20</span>,</span><br><span class="line">            nickname: <span class="keyword">this</span>.nickname,</span><br><span class="line">            groupId: item.id,</span><br><span class="line">            groupName: item.name,</span><br><span class="line">            bridge: []</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'success'</span>, <span class="attr">message</span>: <span class="string">`成功加入<span class="subst">$&#123;item.name&#125;</span>群`</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入群</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line"><span class="comment">// 找到要加入的群</span></span><br><span class="line"><span class="keyword">let</span> group = groups.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.id === obj.groupId</span><br><span class="line">&#125;)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 推入群，用户组 数据对象</span></span><br><span class="line">group.users.push(&#123;</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname</span><br><span class="line">&#125;)</span><br><span class="line">boardCast(&#123;</span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    msg: obj.nickname + <span class="string">'加入了群'</span> + obj.groupName,</span><br><span class="line">    users: users,</span><br><span class="line">    groups: groups,</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    bridge: obj.bridge</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><h4 id="点对点通讯"><a href="#点对点通讯" class="headerlink" title="点对点通讯"></a>点对点通讯</h4><ul><li>设置一个桥数组，有通讯的两者uid<code>this.bridge = [this.uid, item.uid]</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">triggerPersonal (item) &#123;</span><br><span class="line">    <span class="comment">// 不能和自己聊</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.uid === item.uid) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空群id 与群聊互斥</span></span><br><span class="line">    <span class="keyword">this</span>.groupId = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 桥接两用户uid</span></span><br><span class="line">    <span class="keyword">this</span>.bridge = [<span class="keyword">this</span>.uid, item.uid]</span><br><span class="line">    <span class="comment">// 顶部显示与谁聊天信息</span></span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">`和<span class="subst">$&#123;item.nickname&#125;</span>聊天`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="群通讯"><a href="#群通讯" class="headerlink" title="群通讯"></a>群通讯</h4><ul><li>只要点击接受群id就可以了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">triggerGroup (item) &#123;</span><br><span class="line">    <span class="comment">// 获取群内用户组 判断有无此用户id</span></span><br><span class="line">    <span class="keyword">let</span> issome = item.users.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item.uid === <span class="keyword">this</span>.uid</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!issome) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'error'</span>, <span class="attr">message</span>: <span class="string">`您还不是<span class="subst">$&#123;item.name&#125;</span>群成员`</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空桥接数组，与单聊互斥</span></span><br><span class="line">    <span class="keyword">this</span>.bridge = []</span><br><span class="line">    <span class="keyword">this</span>.groupId = item.id</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">`和<span class="subst">$&#123;item.name&#125;</span>群成员聊天`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">send () &#123;</span><br><span class="line">    <span class="comment">// 消除前后空格</span></span><br><span class="line">    <span class="keyword">this</span>.msg = <span class="keyword">this</span>.msg.trim()</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.msg) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 点击左侧的用户对象或群才有bridge和群id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.bridge.length &amp;&amp; !<span class="keyword">this</span>.groupId) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'error'</span>, <span class="attr">message</span>: <span class="string">'请选择发送人或者群'</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.sendMessage(<span class="number">100</span>, <span class="keyword">this</span>.msg)</span><br><span class="line">&#125;,</span><br><span class="line">    sendMessage (type, msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket.send(</span><br><span class="line">            <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                uid: <span class="keyword">this</span>.uid,</span><br><span class="line">                type: type,</span><br><span class="line">                nickname: <span class="keyword">this</span>.nickname,</span><br><span class="line">                msg: msg,</span><br><span class="line">                bridge: <span class="keyword">this</span>.bridge,</span><br><span class="line">                groupId: <span class="keyword">this</span>.groupId</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 每次发送后清空消息栏</span></span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务端广播</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boardCast(&#123;</span><br><span class="line">    <span class="comment">// 2为用户消息，左右侧 。1为系统消息，灰色居中</span></span><br><span class="line">    type: <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 日期</span></span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    msg: obj.msg,</span><br><span class="line">    <span class="comment">// 用户id</span></span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    <span class="comment">// 桥接对对象</span></span><br><span class="line">    bridge: obj.bridge,</span><br><span class="line">    <span class="comment">// 或者群聊id</span></span><br><span class="line">    groupId: obj.groupId,</span><br><span class="line">    <span class="comment">// 消息 已读/未读</span></span><br><span class="line">    status: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="未读消息的闪烁"><a href="#未读消息的闪烁" class="headerlink" title="未读消息的闪烁"></a>未读消息的闪烁</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/noReadMessage.png" alt="noReadMessage"></p><p><strong>联系人，群聊Tab</strong>的<strong>闪烁</strong>,如果有一个消息未读，就显示闪烁v-on:class属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usersUnRead () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.messageList.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 状态 status: 1为未读</span></span><br><span class="line">        <span class="keyword">return</span> item.bridge.length &amp;&amp; item.status === <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="selector-class">.unread</span></span><br><span class="line"><span class="selector-tag">animation</span> <span class="selector-tag">fColorAni</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">infinite</span></span><br><span class="line">@<span class="keyword">keyframes</span> fColorAni</span><br><span class="line">  <span class="number">0%</span></span><br><span class="line">    color $green</span><br><span class="line">  <span class="number">50%</span></span><br><span class="line">    color #<span class="number">46</span>b0ff</span><br><span class="line">  <span class="number">100%</span></span><br><span class="line">    color #<span class="number">333</span></span><br></pre></td></tr></table></figure><p><strong>未读数量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">currentUserList () &#123;</span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">this</span></span><br><span class="line">    vm.users.map(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">        user.unread = <span class="keyword">this</span>.messageList.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                item.bridge.length &amp;&amp; item.uid === user.uid &amp;&amp; item.status === <span class="number">1</span></span><br><span class="line">            )</span><br><span class="line">        &#125;).length</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> vm.users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tips-num"</span> <span class="attr">v-if</span>=<span class="string">"item.unread"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.unread&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有未读数量就将他展示出来</p><hr><h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><p>通过此类qq聊天项目，对 WebSocket 有了一定认识，其实它并不神秘。当创建 WebSocket 实例的时候，会发一个 HTTP 请求，请求报文中有个特殊的字段 Upgrade ，然后这个连接会由 HTTP 协议转换为 WebSocket 协议，这样客户端和服务端建立了全双工通信，通过 WebSocket 的 send 方法和 onmessage 事件就可以通过这条通信连接交换信息。</p><p>时间有限，希望寒假能把这个项目完善</p><ol><li><p>登陆，注册 加盐加密</p></li><li><p>用户，群组，关系，聊天信息，数据库建立</p></li></ol><hr><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a><a href="https://github.com/2249038142/socket--" target="_blank" rel="noopener">项目地址</a></h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现socket点对点，群-通讯&quot;&gt;&lt;a href=&quot;#实现socket点对点，群-通讯&quot; class=&quot;headerlink&quot; title=&quot;实现socket点对点，群 通讯&quot;&gt;&lt;/a&gt;实现socket点对点，群 通讯&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;Java语言不太熟悉，根据老师的思路，实现了 node websocket的简单通讯，前台用的vue。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>call,aplly和bind的内部是如何实现的？</title>
    <link href="http://yoursite.com/2019/12/25/call,aplly%E5%92%8Cbind%E7%9A%84%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/12/25/call,aplly%E5%92%8Cbind%E7%9A%84%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/</id>
    <published>2019-12-25T01:32:06.678Z</published>
    <updated>2019-12-25T01:32:06.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call-aplly和bind的内部是如何实现的？"><a href="#call-aplly和bind的内部是如何实现的？" class="headerlink" title="call,aplly和bind的内部是如何实现的？"></a>call,aplly和bind的内部是如何实现的？</h1><blockquote><p>看的掘金上的，哪天还得手写一下加深理解</p></blockquote><p>call 和 apply 的功能相同，区别在于传参的方式不一样:</p><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><ul><li>fn.call(obj, arg1, arg2, …),调用一个函数, 具有一个指定的this值和分别地提供的参数(参数的列表)。</li><li>fn.apply(obj, [argsArray]),调用一个函数，具有一个指定的this值，以及作为一个数组（或类数组对象）提供的参数。</li></ul><blockquote><p>call核心:</p></blockquote><ul><li>将函数设为传入参数的属性</li><li>指定this到函数并传入给定参数执行函数</li><li>如果不传入参数或者参数为null，默认指向为 window / global</li><li>删除参数上的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的是 null 或者是 undefined, 那么指向this指向 window/global */</span></span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的不是null或者是undefined, 那么必须是一个对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">//this指向的是当前的函数(Function的实例)</span></span><br><span class="line">    <span class="keyword">let</span> rest = [...arguments].slice(<span class="number">1</span>);<span class="comment">//获取除了this指向对象以外的参数, 空数组slice后返回的仍然是空数组</span></span><br><span class="line">    <span class="keyword">let</span> result = context.fn(...rest); <span class="comment">//隐式绑定,当前函数的this指向了context.</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'Selina'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Chirs'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">job, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(job, age);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="string">'programmer'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// Selina programmer 20</span></span><br><span class="line">bar.call(<span class="literal">null</span>, <span class="string">'teacher'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 浏览器环境: Chirs teacher 25; node 环境: undefined teacher 25</span></span><br></pre></td></tr></table></figure><blockquote><p>apply:</p></blockquote><p>apply的实现和call很类似，但是需要注意他们的参数是不一样的，apply的第二个参数是数组或类数组.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined时,设置默认值</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(rest === <span class="literal">undefined</span> || rest === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//undefined 或者 是 null 不是 Iterator 对象，不能被 ...</span></span><br><span class="line">        result = context.fn(rest);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> rest === <span class="string">'object'</span>) &#123;</span><br><span class="line">        result = context.fn(...rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'Selina'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Chirs'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">job, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(job, age);</span><br><span class="line">&#125;</span><br><span class="line">bar.apply(foo, [<span class="string">'programmer'</span>, <span class="number">20</span>]);</span><br><span class="line"><span class="comment">// Selina programmer 20</span></span><br><span class="line">bar.apply(<span class="literal">null</span>, [<span class="string">'teacher'</span>, <span class="number">25</span>]);</span><br><span class="line"><span class="comment">// 浏览器环境: Chirs programmer 20; node 环境: undefined teacher 25</span></span><br></pre></td></tr></table></figure><blockquote><p>bind</p></blockquote><p>bind 和 call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"not a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    Fn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [...args, ...arguments]; <span class="comment">//bind传递的参数和函数调用时传递的参数拼接</span></span><br><span class="line">        context = <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context || <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原型链</span></span><br><span class="line">    bound.prototype = <span class="keyword">new</span> Fn();</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age, job, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name , age, job, gender);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Yve = &#123;<span class="attr">name</span> : <span class="string">'Yvette'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> result = person.bind(Yve, <span class="number">22</span>, <span class="string">'enginner'</span>)(<span class="string">'female'</span>);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;call-aplly和bind的内部是如何实现的？&quot;&gt;&lt;a href=&quot;#call-aplly和bind的内部是如何实现的？&quot; class=&quot;headerlink&quot; title=&quot;call,aplly和bind的内部是如何实现的？&quot;&gt;&lt;/a&gt;call,aplly和bind的内部是如何实现的？&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;看的掘金上的，哪天还得手写一下加深理解&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;call 和 apply 的功能相同，区别在于传参的方式不一样:&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>12月leetcode(链表)</title>
    <link href="http://yoursite.com/2019/12/25/12%E6%9C%88leetcode(%E9%93%BE%E8%A1%A8)/"/>
    <id>http://yoursite.com/2019/12/25/12%E6%9C%88leetcode(%E9%93%BE%E8%A1%A8)/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2019-12-25T01:54:18.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12月leetcode-链表"><a href="#12月leetcode-链表" class="headerlink" title="12月leetcode(链表)"></a>12月leetcode(链表)</h1><h3 id="73-删除列表中的节点"><a href="#73-删除列表中的节点" class="headerlink" title="73 - 删除列表中的节点"></a>73 - 删除列表中的节点</h3><p><strong>题目</strong><br>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], node = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>解：</strong></p><blockquote><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p></blockquote><p>就是将这个节点的下一个复制到这一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(node, node.next)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  node.val = node.next.val</span><br><span class="line">  node.next = node.next.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>解：</strong> 因为是单链表 所以走到前一个位置就要停止 把下下个节点 挪到下一个，双指针为了考虑头节点删除这一特殊情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = head</span><br><span class="line">    <span class="comment">// 先指针探路，走到删除点的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        first = first.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是空的说明 要删除的是首个节点 因为走到底了</span></span><br><span class="line">    <span class="keyword">if</span>(!first) <span class="keyword">return</span> head.next</span><br><span class="line">    <span class="keyword">let</span> second = head</span><br><span class="line">    <span class="comment">// 跟着步伐 当先指针走到底 后指针走到要删除前一个 跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(first.next) &#123;</span><br><span class="line">        first = first.next</span><br><span class="line">        second = second.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为在要删除的前一个 所以把下下个给到下个 等于把它抛弃了</span></span><br><span class="line">    second.next = second.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [pre, cur] = [<span class="literal">null</span>, head]</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        [cur.next, pre, cur] = [pre, cur, cur.next]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 访问到末尾节点返回</span></span><br><span class="line">    <span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</span></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(head &amp;&amp; head.next)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> secondHalf = head;</span><br><span class="line">  <span class="keyword">let</span> firstHalf = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (head &amp;&amp; head.next) &#123;</span><br><span class="line">      <span class="comment">// 每次走两步可以反转到一半</span></span><br><span class="line">    head = head.next.next;</span><br><span class="line">     <span class="comment">// 前半部分反转</span></span><br><span class="line">      <span class="comment">//[secondNode.next, firstNode, secondNode] = [firstNode, secondNode, secondNode.next] 结构赋值报错，我记得反转链表题没有问题很奇怪</span></span><br><span class="line">    <span class="keyword">let</span> temp = secondHalf;</span><br><span class="line">    secondHalf = secondHalf.next;</span><br><span class="line">    temp.next = firstHalf;</span><br><span class="line">    firstHalf = temp;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 如果是单数 往后走一位</span></span><br><span class="line">  <span class="keyword">if</span> (head) secondHalf = secondHalf.next;</span><br><span class="line">  <span class="keyword">while</span>(secondHalf) &#123;</span><br><span class="line">      <span class="comment">// 从中间往两边比较</span></span><br><span class="line">    <span class="keyword">if</span> (firstHalf.val !== secondHalf.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    firstHalf = firstHalf.next;</span><br><span class="line">    secondHalf = secondHalf.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p>使用Symbol定义唯一值，单链表一直往下走，如果有相同就说明之前定义过，为环形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flag = <span class="built_in">Symbol</span>()</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val === flag) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        head.val = flag</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>symbol</strong> 是一种基本数据类型 （<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener">primitive data type</a>）。<code>Symbol()</code>函数会返回<strong>symbol</strong>类型的值，该类型具有静态属性和静态方法。</p><p>每个从<code>Symbol()</code>返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。更进一步的解析见—— <a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" target="_blank" rel="noopener">glossary entry for Symbol</a>。</p></blockquote><p><strong>其他解：</strong>双指针。</p><ul><li>没有环，那么快指针会先到终点停下来，</li><li>如果存在环，那么他们一定会在某一时刻相遇</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = head;</span><br><span class="line">  <span class="keyword">let</span> second = head;</span><br><span class="line">  <span class="keyword">while</span>(first &amp;&amp; first.next) &#123;</span><br><span class="line">    first = first.next.next;</span><br><span class="line">    second = second.next;</span><br><span class="line">    <span class="keyword">if</span> (first === second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="数组的哪些API会改变原数组？"><a href="#数组的哪些API会改变原数组？" class="headerlink" title="数组的哪些API会改变原数组？"></a>数组的哪些API会改变原数组？</h3><h4 id="补充：这个需要记忆一下"><a href="#补充：这个需要记忆一下" class="headerlink" title="补充：这个需要记忆一下"></a>补充：这个需要记忆一下</h4><blockquote><p>修改原数组的API有:</p></blockquote><p><code>splice/reverse/fill/copyWithin/sort/push/pop/unshift/shift</code></p><blockquote><p>不修改原数组的API有:</p></blockquote><p><code>slice/map/forEach/every/filter/reduce/entries/find</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;12月leetcode-链表&quot;&gt;&lt;a href=&quot;#12月leetcode-链表&quot; class=&quot;headerlink&quot; title=&quot;12月leetcode(链表)&quot;&gt;&lt;/a&gt;12月leetcode(链表)&lt;/h1&gt;&lt;h3 id=&quot;73-删除列表中的节点&quot;&gt;&lt;a href=&quot;#73-删除列表中的节点&quot; class=&quot;headerlink&quot; title=&quot;73 - 删除列表中的节点&quot;&gt;&lt;/a&gt;73 - 删除列表中的节点&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;br&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>抽离首页小卡片组件</title>
    <link href="http://yoursite.com/2019/12/21/%E6%8A%BD%E7%A6%BB%E9%A6%96%E9%A1%B5%E5%B0%8F%E5%8D%A1%E7%89%87/"/>
    <id>http://yoursite.com/2019/12/21/%E6%8A%BD%E7%A6%BB%E9%A6%96%E9%A1%B5%E5%B0%8F%E5%8D%A1%E7%89%87/</id>
    <published>2019-12-21T12:13:22.194Z</published>
    <updated>2019-12-21T12:15:14.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽离首页小卡片组件"><a href="#抽离首页小卡片组件" class="headerlink" title="抽离首页小卡片组件"></a>抽离首页小卡片组件</h1><h3 id="dpr不同-获取图片倍数问题"><a href="#dpr不同-获取图片倍数问题" class="headerlink" title="dpr不同 获取图片倍数问题"></a>dpr不同 获取图片倍数问题</h3><p>之前的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">storage-info-bg-mixin</span><span class="params">(dpr)</span></span></span><br><span class="line">      <span class="variable">$dpr</span> = <span class="string">"@"</span> + dpr</span><br><span class="line">      &amp;-lun</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/LUN"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-server</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/server"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-file</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/file"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-cifsshare</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/diskcifs"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat center</span><br><span class="line">      &amp;-nfsshare</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/disknfs"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat center</span><br><span class="line">      &amp;-ftpshare</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/diskftp"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat center</span><br><span class="line">      &amp;-object</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/object"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-rent</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/rent"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-bucket</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/bucket"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对所有的mixin再做一层mixin</span></span><br><span class="line">  media-mixin(mixin)</span><br><span class="line">      mixin(<span class="string">'1x'</span>)</span><br><span class="line">      @media screen and (-webkit-min-device-pixel-ratio: <span class="number">2</span>),  screen and (min--moz-device-pixel-ratio: <span class="number">2</span>)</span><br><span class="line">          mixin(<span class="string">'2x'</span>)</span><br><span class="line">      @media screen and (-webkit-min-device-pixel-ratio: <span class="number">3</span>),  screen and (min--moz-device-pixel-ratio: <span class="number">3</span>)</span><br><span class="line">          mixin(<span class="string">'3x'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>非常的繁琐,每个不同图片的都要添加一行，还用到了stylus <code>mixin</code>嵌套难以理解</p><p><strong>我的方式</strong></p><p>首先在父组件获取屏幕dpr，防止有个别屏幕dpr不是整数，1.5，1.25什么的，取整，默认dpr为一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getFloorDPR() &#123;</span><br><span class="line">    <span class="keyword">let</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">    <span class="keyword">let</span> dprMin = <span class="number">1</span>,</span><br><span class="line">        dprMax = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(dpr &gt;= dprMin &amp;&amp; dpr &lt; dprMax) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dpr = <span class="built_in">Math</span>.floor(dpr) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件props，传入图片名即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    image: &#123;   <span class="comment">//传入[图片名 ，屏幕dpr]</span></span><br><span class="line">        type: <span class="built_in">Array</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> [<span class="string">'server'</span>, <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>style动态绑定背景图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"storage-info-bg"</span> <span class="attr">:style</span>=<span class="string">"bgIcon"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在data中 得到传过来的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        bgIcon: &#123;</span><br><span class="line">            background: <span class="string">`url('/.../<span class="subst">$&#123;<span class="keyword">this</span>.image[<span class="number">0</span>]&#125;</span>@<span class="subst">$&#123;<span class="keyword">this</span>.image[<span class="number">1</span>]&#125;</span>x.png') no-repeat`</span> </span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">getShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;共享目录&apos;)&#125;：` + `$&#123;this.getShareCount&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getCifsShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;CIFS目录&apos;)&#125;：` + `$&#123;this.cifsStore.cifs_share_dir_num || 0&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getNfsShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;NFS目录&apos;)&#125;：` + `$&#123;this.nfsStore.nfs_share_dir_num || 0&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getFtpShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;FTP目录&apos;)&#125;：` + `$&#123;this.ftpStore.ftp_share_dir_num || 0&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 对象总数</span><br><span class="line">getObjectTotalTip () &#123;</span><br><span class="line">return (`$&#123;_(&apos;对象总数&apos;)&#125;：` +</span><br><span class="line">`$&#123;this.objStore &amp;&amp; this.objStore.object_num || 0&#125;` +</span><br><span class="line">_(&apos;个&apos;));</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 用户账号</span><br><span class="line">getUsersTip () &#123;</span><br><span class="line">return (`$&#123;_(&apos;用户账号&apos;)&#125;：` +</span><br><span class="line">`$&#123;this.objStore &amp;&amp; this.objStore.user_num || 0&#125;` +</span><br><span class="line">_(&apos;个</span><br></pre></td></tr></table></figure><p>非常的繁琐,所以子组件简化为两个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getCountTip() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">`<span class="subst">$&#123;_(<span class="keyword">this</span>.label)&#125;</span>：<span class="subst">$&#123;<span class="keyword">this</span>.count&#125;</span> <span class="subst">$&#123;_(<span class="string">'个'</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;,</span><br><span class="line">    getConnectTip() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">`<span class="subst">$&#123;_(<span class="string">'已连接'</span>)&#125;</span>：<span class="subst">$&#123;<span class="keyword">this</span>.connect&#125;</span> <span class="subst">$&#123;_(<span class="string">'个'</span>)&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="单位拆分"><a href="#单位拆分" class="headerlink" title="单位拆分"></a>单位拆分</h3><p><strong>原代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"number"</span>&gt;</span>&#123;&#123;showNumber(objStore &amp;&amp; objStore.object_num).val&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"unit"</span>&gt;</span><span class="tag">&lt;<span class="name">lang</span>&gt;</span>&#123;&#123;showNumber(objStore &amp;&amp; objStore.object_num).unit&#125;&#125;<span class="tag">&lt;/<span class="name">lang</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每次返回个对象，每次都要调用两次方法，非常别扭，substr这个方法MDN说已经块要废弃了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">showNumber (num) &#123;</span><br><span class="line">    <span class="keyword">let</span> showNum = numSize(num || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (showNum &amp;&amp; !lodash.isNumber(showNum))&#123;</span><br><span class="line">        <span class="keyword">let</span> numPosition = showNum.search(<span class="regexp">/万|亿/g</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            val: showNum.substr(<span class="number">0</span>, numPosition),</span><br><span class="line">            unit: showNum.substr(numPosition)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        val: showNum,</span><br><span class="line">        unit: _(<span class="string">'个'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><hr><p><strong>我的优化</strong>：正则优化 使用 <code>split</code>，然后把计算放入data，template直接取，避免重复调用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"number"</span>&gt;</span>&#123;&#123;unitValue[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"number-unit"</span>&gt;</span>&#123;&#123;unitValue[1]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showNumber() &#123;</span><br><span class="line">    <span class="keyword">let</span> showNum = numSize(<span class="keyword">this</span>.count);</span><br><span class="line">    lodash.isNumber(showNum)</span><br><span class="line">        ? <span class="keyword">this</span>.unitValue = [showNum, _(<span class="string">'个'</span>)]</span><br><span class="line">        : <span class="keyword">this</span>.unitValue = showNum.split(<span class="regexp">/(万|亿)/g</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抽离首页小卡片组件&quot;&gt;&lt;a href=&quot;#抽离首页小卡片组件&quot; class=&quot;headerlink&quot; title=&quot;抽离首页小卡片组件&quot;&gt;&lt;/a&gt;抽离首页小卡片组件&lt;/h1&gt;&lt;h3 id=&quot;dpr不同-获取图片倍数问题&quot;&gt;&lt;a href=&quot;#dpr不同-获取图片倍数问题&quot; class=&quot;headerlink&quot; title=&quot;dpr不同 获取图片倍数问题&quot;&gt;&lt;/a&gt;dpr不同 获取图片倍数问题&lt;/h3&gt;&lt;p&gt;之前的代码：&lt;/p&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;storage-info-bg-mixin&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dpr)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;@&quot;&lt;/span&gt; + dpr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-lun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/LUN&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/server&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/file&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-cifsshare&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/diskcifs&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat center&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-nfsshare&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/disknfs&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat center&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-ftpshare&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/diskftp&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat center&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/object&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-rent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/rent&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;amp;-bucket&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt; url(&lt;span class=&quot;string&quot;&gt;&quot;../img/bucket&quot;&lt;/span&gt; + &lt;span class=&quot;variable&quot;&gt;$dpr&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;) no-repeat left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 对所有的mixin再做一层mixin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  media-mixin(mixin)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mixin(&lt;span class=&quot;string&quot;&gt;&#39;1x&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      @media screen and (-webkit-min-device-pixel-ratio: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;),  screen and (min--moz-device-pixel-ratio: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          mixin(&lt;span class=&quot;string&quot;&gt;&#39;2x&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      @media screen and (-webkit-min-device-pixel-ratio: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;),  screen and (min--moz-device-pixel-ratio: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          mixin(&lt;span class=&quot;string&quot;&gt;&#39;3x&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="组件提取" scheme="http://yoursite.com/categories/%E7%BB%84%E4%BB%B6%E6%8F%90%E5%8F%96/"/>
    
    
      <category term="组件" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"/>
    
      <category term="抽象" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何使用css翻转背景图</title>
    <link href="http://yoursite.com/2019/12/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8css%E7%BF%BB%E8%BD%AC%E8%83%8C%E6%99%AF%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/12/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8css%E7%BF%BB%E8%BD%AC%E8%83%8C%E6%99%AF%E5%9B%BE/</id>
    <published>2019-12-21T12:13:18.711Z</published>
    <updated>2019-12-21T12:14:18.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何使用css翻转背景图"><a href="#如何使用css翻转背景图" class="headerlink" title="如何使用css翻转背景图"></a>如何使用css翻转背景图</h1><p>在网上看的css 翻转，要么用html<img>标签，实体图，要么就是全部翻转了，</p><p>想到一个好办法，用伪元素处理背景图片</p><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    .site-info-slave</span><br><span class="line">        <span class="attribute">position</span> relative</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">1</span></span><br><span class="line">        &amp;::before</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">""</span></span><br><span class="line">            <span class="attribute">position</span>: absolute</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">            <span class="attribute">z-index</span>: -<span class="number">1</span></span><br><span class="line">            <span class="attribute">background</span>: url(xxx) no-repeat</span><br><span class="line">            <span class="attribute">transform</span>: rotate(-<span class="number">180deg</span>)</span><br></pre></td></tr></table></figure><p>可以进行任意角度旋转父元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><p>就防止背景超出</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何使用css翻转背景图&quot;&gt;&lt;a href=&quot;#如何使用css翻转背景图&quot; class=&quot;headerlink&quot; title=&quot;如何使用css翻转背景图&quot;&gt;&lt;/a&gt;如何使用css翻转背景图&lt;/h1&gt;&lt;p&gt;在网上看的css 翻转，要么用html&lt;img&gt;标签，实体图，要么就是全部翻转了，&lt;/p&gt;&lt;p&gt;想到一个好办法，用伪元素处理背景图片&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>12月leetcode（字符串）</title>
    <link href="http://yoursite.com/2019/12/01/12%E6%9C%88leetcode%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/01/12%E6%9C%88leetcode%E7%AE%97%E6%B3%95/</id>
    <published>2019-12-01T14:21:26.347Z</published>
    <updated>2019-12-04T15:22:41.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12月leetcode（字符串）"><a href="#12月leetcode（字符串）" class="headerlink" title="12月leetcode（字符串）"></a>12月leetcode（字符串）</h1><blockquote><p>下个小目标，12月份刷20道算法，不难，但是希望能坚持，leetcode 探索的基础算法，一直拖，之前刷了数组，现在才到字符串。看到别人半年刷了200多个+剑指 我就知道差距了，先坚持下来再说。</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>刷这些个算法 首先自己写，写不出来再看别人的源码，写出来了，学习执行时间靠前的代码，发现高手的同时也是语言高手，多向牛人学习他们的思维方式。</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>我的解:</strong></p><ul><li>先判断长度，不等于直接返回</li><li>拆成数组，然后排序，再和字符串比较</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">''</span>).sort().join() == t.split(<span class="string">''</span>).sort().join()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优解：</strong></p><p>定义一个26位的map 有遍历 往相应的槽里+1</p><p>这样就知道各个字符出现的次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">// 创建一个26位的数组 里面都是0</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line"><span class="comment">// 取这个字母的unicode -97 a 为 0</span></span><br><span class="line">o[s[i].charCodeAt(<span class="number">0</span>) - <span class="number">97</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">p[t[i].charCodeAt(<span class="number">0</span>) - <span class="number">97</span>]++</span><br><span class="line">&#125;</span><br><span class="line">o = o.toString()</span><br><span class="line">p = p.toString()</span><br><span class="line"><span class="comment">// 数组变字符串然后</span></span><br><span class="line"><span class="keyword">return</span> o === p</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>charCodeAt()</code> 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。</p><p><code>toString()</code> 方法返回指定对象的字符串形式。</p><p><code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.fill(value[, start[, end]])</span><br></pre></td></tr></table></figure><h4 id="arr-fill-参数"><a href="#arr-fill-参数" class="headerlink" title="arr.fill()参数"></a>arr.fill()参数</h4><ul><li><p><code>value</code></p><p>用来填充数组元素的值。</p></li><li><p><code>start</code> 可选</p><p>起始索引，默认值为0。</p></li><li><p><code>end</code> 可选</p><p>终止索引，默认值为 <code>this.length</code>。</p></li></ul><hr><h3 id="验证回文字符串"><a href="#验证回文字符串" class="headerlink" title="验证回文字符串"></a>验证回文字符串</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>我的解：</strong>使用正则排除所有字母数字之外的符号，然后转小写，数组化 反转 字符串化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    x = s.replace(<span class="regexp">/[^a-zA-Z0-9]/g</span>, <span class="string">''</span>).toLowerCase()</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) === x</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h3><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>解：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 清除前后空白符</span></span><br><span class="line">     str = str.trim();</span><br><span class="line">     <span class="comment">// 正则，如果不是正负 数字开头 返回 0</span></span><br><span class="line">     <span class="keyword">if</span>(!<span class="regexp">/^[+|-]?\d+/</span>.test(str)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取 字符串 转 数</span></span><br><span class="line">     <span class="keyword">let</span> val = + str.match(<span class="regexp">/^[+|-]?\d+/</span>);</span><br><span class="line">    <span class="keyword">let</span> base = <span class="number">2</span> ** <span class="number">31</span></span><br><span class="line">     <span class="keyword">let</span> min = -base;</span><br><span class="line">     <span class="keyword">let</span> max = base<span class="number">-1</span>;</span><br><span class="line">     <span class="comment">// 判断大小边界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(val, max), min)</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>简化后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> val = str.trim().match(<span class="regexp">/^[+|-]?\d+/</span>)</span><br><span class="line">    <span class="keyword">return</span> val ? <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(val, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), - (<span class="number">2</span>**<span class="number">31</span>)) : <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h3><p>实现 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strStr()</a> 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>我的解：</strong>看了这个题后，想了想，好像就是indexOf方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; haystack</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; needle</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haystack.indexOf(needle)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以在之前做一些判断直接返回 提升效率，我就不死磕了</p><hr><h3 id="报数"><a href="#报数" class="headerlink" title="报数"></a>报数</h3><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> 被读作 <code>&quot;one 1&quot;</code> (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>, “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> , <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出报数序列的第 <em>n</em> 项。</p><p>注意：整数顺序将表示为一个字符串。</p><p><strong>解：</strong>正则匹配到数字， （\d）\1*表示匹配括号内相同的数字，匹配0到无数次，第一个返回匹配到相同数字的长度，第二个匹配到的字。</p><p>eg: ()()\1 匹配第一个括号 ()()\2匹配第二个括号内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        prev = prev.replace(<span class="regexp">/(\d)\1*/g</span>, item =&gt;<span class="string">`<span class="subst">$&#123;item.length&#125;</span><span class="subst">$&#123;item[<span class="number">0</span>]&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>replace()方法</strong></p><p><code>str.replace(regexp|substr, newSubStr|function)</code><br>参数<br><code>regexp (pattern)</code><br>一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。<br><code>substr (pattern)</code><br>一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。<br><code>newSubStr (replacement)</code><br>用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。<br><code>function (replacement)</code><br>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。</p><hr><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>解：</strong>先判断数组长为 0 1 直接 返回</p><p>然后用第一项为比较项 如果没有在首位找到，就从末尾截取一位，直到匹配，</p><p>匹配成功 下一项匹配 返回最后还剩的截取字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; strs</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr0 = strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span>(!arr0) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> len = strs.length</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs[i].indexOf(arr0) !== <span class="number">0</span>)&#123;</span><br><span class="line">            arr0 = arr0.slice(<span class="number">0</span>, arr0.length<span class="number">-1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了速度比较快的代码，才发现 字符串可以用[] ，类似数组取到单个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">''</span></span><br><span class="line">        <span class="comment">// 先取首项长度,遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组长度 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 两个串从第一个开始比较 如果不相等直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][i] !== strs[j][i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相等就加上来</span></span><br><span class="line">        a += strs[<span class="number">0</span>][i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>字符串就到此结束了，刷二遍的时候再把之前写完了的数组还有两个字符串的题补上，</p><p>下次刷链表了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;12月leetcode（字符串）&quot;&gt;&lt;a href=&quot;#12月leetcode（字符串）&quot; class=&quot;headerlink&quot; title=&quot;12月leetcode（字符串）&quot;&gt;&lt;/a&gt;12月leetcode（字符串）&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;下个小目标，12月份刷20道算法，不难，但是希望能坚持，leetcode 探索的基础算法，一直拖，之前刷了数组，现在才到字符串。看到别人半年刷了200多个+剑指 我就知道差距了，先坚持下来再说。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JS双等判断</title>
    <link href="http://yoursite.com/2019/12/01/JS%E5%8F%8C%E7%AD%89%E5%88%A4%E6%96%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2019/12/01/JS%E5%8F%8C%E7%AD%89%E5%88%A4%E6%96%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD/</id>
    <published>2019-12-01T02:13:01.321Z</published>
    <updated>2019-12-01T02:17:55.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS双等判断"><a href="#JS双等判断" class="headerlink" title="JS双等判断"></a>JS双等判断</h1><h3 id="双等"><a href="#双等" class="headerlink" title="双等 =="></a>双等 ==</h3><p><img src="/images/loading.png" data-original="https://pic2.zhimg.com/80/0fc2dd69d7f9d4083f347784446b7f0d_hd.png" alt="img"></p><ul><li><p>N表示ToNumber操作，即将操作数转为数字。</p></li><li><p>P表示ToPrimitive操作，即将操作数转为原始类型的值。</p><blockquote><p>toString()方法用来得到对象的一段文字描述；而valueOf()方法用来得到对象的特征值。</p></blockquote></li></ul><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>布尔值与其他类型的值作比较时，布尔值会转化为数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="literal">false</span> -&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>字符串和数字做==运算时，需要使用ToNumber操作</p><p>当一个对象与一个非对象比较时，需要将对象转化为原始类型</p><p><strong>在运算过程中，所有类型的值都有一种向数字类型转化的趋势。</strong></p><ul><li><strong>undefined == null</strong>，结果是<strong>true</strong>。且它俩与所有其他值比较的结果都是<strong>false</strong>。</li><li><strong>String == Boolean</strong>，需要两个操作数同时转为Number。</li><li><strong>String/Boolean == Number</strong>，需要String/Boolean转为Number。</li><li><strong>Object == Primitive</strong>，需要Object转为Primitive(具体通过<strong>valueOf</strong>和<strong>toString</strong>方法)。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS双等判断&quot;&gt;&lt;a href=&quot;#JS双等判断&quot; class=&quot;headerlink&quot; title=&quot;JS双等判断&quot;&gt;&lt;/a&gt;JS双等判断&lt;/h1&gt;&lt;h3 id=&quot;双等&quot;&gt;&lt;a href=&quot;#双等&quot; class=&quot;headerlink&quot; title=&quot;双等 ==&quot;&gt;&lt;/a&gt;双等 ==&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/loading.png&quot; data-original=&quot;https://pic2.zhimg.com/80/0fc2dd69d7f9d4083f347784446b7f0d_hd.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;N表示ToNumber操作，即将操作数转为数字。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;P表示ToPrimitive操作，即将操作数转为原始类型的值。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;toString()方法用来得到对象的一段文字描述；而valueOf()方法用来得到对象的特征值。&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>总算把你JS原型搞懂了</title>
    <link href="http://yoursite.com/2019/12/01/%E6%80%BB%E7%AE%97%E6%8A%8A%E4%BD%A0JS%E5%8E%9F%E5%9E%8B%E6%90%9E%E6%87%82%E4%BA%86/"/>
    <id>http://yoursite.com/2019/12/01/%E6%80%BB%E7%AE%97%E6%8A%8A%E4%BD%A0JS%E5%8E%9F%E5%9E%8B%E6%90%9E%E6%87%82%E4%BA%86/</id>
    <published>2019-12-01T02:05:18.714Z</published>
    <updated>2019-12-01T02:19:49.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="彻底搞明白JS原型"><a href="#彻底搞明白JS原型" class="headerlink" title="彻底搞明白JS原型"></a>彻底搞明白JS原型</h1><blockquote><p>一周考核中的JS原理题，表面checklist 实则考察Javascript原理，里面有很多题目没有理解，一个一个深挖，理解透，先把JS原型挖透</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>第一次做题的时候只做做对了四分之一，整个人对JavaScript这门语言又懵逼了。跑了三遍案例才过90分，痛定思痛一定要搞明白其中的原理。</p><p>周六便在公司专门找JS原型的文章看。发现涉及的JS其他知识点也有很多。先去了解查看prototype是什么，中途又去看new的理念，接着又是this指向。</p><p>其实这些知识点零零散散在论坛公众号都有看，但是看了似乎懂了，一知半解过几天又忘，感觉JS就像充满未知的无底洞。</p><p>用自己的语言总结一下，时不时复习应该能理解更深。</p><h3 id="new问题"><a href="#new问题" class="headerlink" title="new问题"></a>new问题</h3><p>关键字 <code>new</code> 跟着一个含参函数，用于告知浏览器我们想要创建一个对象</p><p>在调用函数前加一个 <code>new</code> ，它就会返回一个这个函数的实例化<strong>对象</strong>. 然后，就可以在这个对象上面添加一些属性 。</p><p>每次<code>new</code>都会开辟出新的一个堆。</p><ol><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 this</li><li>返回新对象</li></ol><h3 id="Javascript各元素诞生"><a href="#Javascript各元素诞生" class="headerlink" title="Javascript各元素诞生"></a>Javascript各元素诞生</h3><p>__ proto __ 产生</p><p>当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>_proto_</code>属性。</p><p>prototype 原型</p><p><a href="https://zhuanlan.zhihu.com/p/22989691" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22989691</a></p><p><img src="/images/loading.png" data-original="https://pic1.zhimg.com/v2-1b90d4ec60713acce99df0c498fff794_r.jpg" alt="preview"></p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/2/24/1691fc9305a0c6b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="proto-与prototype"><a href="#proto-与prototype" class="headerlink" title="_ proto_ 与prototype"></a>_ <em>proto_</em> 与prototype</h3><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/4/11/16a0b8d871768297?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="整体的联系"></p><p>我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是<strong>对象</strong>所独有的；② <code>prototype</code>属性是<strong>函数</strong>所独有的。但是由于JS中函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性，这点是致使我们产生困惑的很大原因之一</p><hr><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><strong>我们知道 apply() 和 call() 都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部的 this 指向）</strong>。然后，因为这两个方法会立即调用，所以为了弥补它们的缺失，还有个方法 <code>bind()</code>，它不会立即调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = &#123;</span><br><span class="line">    num: <span class="number">2</span>,</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>).onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">      &#125;).bind(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// &#125;).call(this);</span></span><br><span class="line">      <span class="comment">// &#125;).apply(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里的 this 是 fun，所以可以正确地访问 num,</span></span><br><span class="line"><span class="comment">     * 如果使用 bind()，会在点击之后打印 2；</span></span><br><span class="line"><span class="comment">     * 如果使用 call() 或者 apply()，那么在刷新网页的时候就会打印 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  fn.fun();</span><br></pre></td></tr></table></figure><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a = <span class="number">100</span>,</span><br><span class="line">    log:<span class="function"><span class="params">b</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    log2:<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.log()  <span class="comment">// 指向global</span></span><br><span class="line">obj.log2() <span class="comment">// 指向obj</span></span><br></pre></td></tr></table></figure><p>箭头函数的this与创建时的封闭词法上下文的this保持一致。</p><p><strong><code>this</code> 总是指向调用它所在方法的对象</strong></p><ul><li><strong>一般 this 指向问题，会发生在回调函数中。所以我们在写回调函数时，要注意一下 this 的指向问题。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  birth: 1995,</span><br><span class="line">  getAge: function() &#123;</span><br><span class="line">    var b = this.birth; // 1995;</span><br><span class="line">    var fn = function() &#123;</span><br><span class="line">      return this.birth; </span><br><span class="line">    &#125;;</span><br><span class="line">    return fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getAge(); // undefined</span><br></pre></td></tr></table></figure><p><code>fn</code> 中的 <code>this</code> 指向变成 <code>undefined</code> 了。<br>因为这里重新定义了个 function,有一个新的函数上下文,</p><p>通过<code>call()</code>修正this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  birth: <span class="number">1999</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1999</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.birth; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> fn.call(obj); <span class="comment">// 通过 call()，将 obj 的 this 指向了 fn 中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge(); <span class="comment">// 1999</span></span><br></pre></td></tr></table></figure><p>也可以把上个this复值 <code>that = this</code></p><p>也可以使用箭头函数，箭头函数引用父级上下文</p><hr><h3 id="搞明白之后，可以自信解题了"><a href="#搞明白之后，可以自信解题了" class="headerlink" title="搞明白之后，可以自信解题了"></a>搞明白之后，可以自信解题了</h3><p>在网上搞了几个类似的题目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">A.prototype.n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  n: <span class="number">2</span>,</span><br><span class="line">  m: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.n);</span><br><span class="line"><span class="built_in">console</span>.log(b.m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c.n);</span><br><span class="line"><span class="built_in">console</span>.log(c.m);</span><br></pre></td></tr></table></figure><p>A.prototype 函数的原型对象上增个 {n： 1}</p><p>然后c的原型对象被重新定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">undefine</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.a();</span><br><span class="line">f.b();</span><br><span class="line"></span><br><span class="line">F.a();</span><br><span class="line">F.b();</span><br></pre></td></tr></table></figure><p>对象的原型对象 为 <strong>神对象</strong> 加一个输出a的函数</p><p>函数的原型对象 <strong>机器对象</strong> 加一个输出b的函数</p><p>f为函数F的实例化对象</p><p>函数的原型对象 <strong>机器</strong> 通过原型链找到对象的原型对象 <strong>神</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">error<span class="string">`not a function`</span></span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>);</span><br></pre></td></tr></table></figure><p>问题1：1.<code>p.__proto__</code>等于什么？</p><p>p为Person的实例化对象，就是<code>Person.Prototype</code></p><p>问题2：<code>Person.__proto__</code>等于什么？</p><p>函数 对象原型 <strong>机器</strong><code>Fuction.Prototype</code></p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;,</span><br><span class="line">    F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="string">'value a'</span>;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="string">'value b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.a);</span><br><span class="line"><span class="built_in">console</span>.log(foo.b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(F.a);</span><br><span class="line"><span class="built_in">console</span>.log(F.b)</span><br></pre></td></tr></table></figure><p>函数原型对象 <strong>机器</strong> 通过 原型链 找到对象原型对象 <strong>神</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">undefine</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><hr><p>在开始的时候，看着看着会看晕了</p><p>连续看了无数文章解析，自己敲，单步调试多次后，我仿佛打通了JS二脉，对JS原型有了自己的理解。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;彻底搞明白JS原型&quot;&gt;&lt;a href=&quot;#彻底搞明白JS原型&quot; class=&quot;headerlink&quot; title=&quot;彻底搞明白JS原型&quot;&gt;&lt;/a&gt;彻底搞明白JS原型&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;一周考核中的JS原理题，表面checklist 实则考察Javascript原理，里面有很多题目没有理解，一个一个深挖，理解透，先把JS原型挖透&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript原理" scheme="http://yoursite.com/tags/javascript%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>企业级web开发流程</title>
    <link href="http://yoursite.com/2019/11/17/%E4%BC%81%E4%B8%9A%E7%BA%A7web%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/17/%E4%BC%81%E4%B8%9A%E7%BA%A7web%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</id>
    <published>2019-11-17T14:02:18.980Z</published>
    <updated>2019-12-01T02:24:14.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="企业级web开发流程"><a href="#企业级web开发流程" class="headerlink" title="企业级web开发流程"></a>企业级web开发流程</h1><blockquote><p>入职一周，大致解了了企业的开发流程，我们工作室有很多借鉴的地方，比如UI设计师可以直接用sketch导出html格式的文章，前后端开发之前一定要定义好接口规范，学到了以后就避免很多返工</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><h4 id="1-需求阶段"><a href="#1-需求阶段" class="headerlink" title="1. 需求阶段"></a>1. 需求阶段</h4><ul><li><p>用户/市场调研</p></li><li><p>问题分析：获取需求定义，又称软件需求规约.</p></li><li><p>需求分析：需求分析生成功能规约。</p></li><li><p>项目评估：了解开发难度，评估开发工作量，指定开大进度计划和里程碑节点。</p><p>对应岗位：产品经理</p><p>开发工具：Axure, xmind</p></li></ul><h4 id="2-设计阶段"><a href="#2-设计阶段" class="headerlink" title="2. 设计阶段"></a>2. 设计阶段</h4><ul><li><p><strong>交互设计</strong></p><p>对应岗位：交互设计师</p><p>开发工具：Axure</p></li><li><p><strong>UI设计</strong></p><p>对应岗位：UI设计师</p><p>开发工具：PS,sketch</p></li></ul><p><strong>每次定稿之前，必须前后端开发一起参与审稿，避免返工</strong></p><h4 id="3-开发阶段"><a href="#3-开发阶段" class="headerlink" title="3. 开发阶段"></a>3. 开发阶段</h4><p>开发之前，前后端务必，了解好整个软件系统结构，包括子系统、模块以及相关层次、说明每一模块的<strong>接口定义，命名规则</strong>，模块之间的调用关系等。</p><h4 id="4-测试阶段"><a href="#4-测试阶段" class="headerlink" title="4. 测试阶段"></a>4. 测试阶段</h4><ul><li>功能测试</li><li>压力测试</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;企业级web开发流程&quot;&gt;&lt;a href=&quot;#企业级web开发流程&quot; class=&quot;headerlink&quot; title=&quot;企业级web开发流程&quot;&gt;&lt;/a&gt;企业级web开发流程&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;入职一周，大致解了了企业的开发流程，我们工作室有很多借鉴的地方，比如UI设计师可以直接用sketch导出html格式的文章，前后端开发之前一定要定义好接口规范，学到了以后就避免很多返工&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="开发流程" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
      <category term="开发流程" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端复习题</title>
    <link href="http://yoursite.com/2019/11/10/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/11/10/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0/</id>
    <published>2019-11-10T13:42:40.097Z</published>
    <updated>2019-12-01T02:17:04.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、CSS问题"><a href="#一、CSS问题" class="headerlink" title="一、CSS问题"></a>一、CSS问题</h3><h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><blockquote><p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><h4 id="2-css3的新特性"><a href="#2-css3的新特性" class="headerlink" title="2.css3的新特性"></a>2.css3的新特性</h4><blockquote><p>transtion transition-property 规定设置过渡效果的 CSS 属性的名称。</p></blockquote><blockquote><p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p></blockquote><blockquote><p>transition-timing-function 规定速度效果的速度曲线。</p></blockquote><blockquote><p>transition-delay 定义过渡效果何时开始。</p></blockquote><blockquote><p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p></blockquote><blockquote><p>ainimation实现动画效果主要由两部分组成：</p></blockquote><blockquote><p>通过类似Flash动画中的帧来声明一个动画；</p></blockquote><blockquote><p>在animation属性中调用关键帧声明的动画。</p></blockquote><blockquote><p>translate 3D建模效果</p></blockquote><h4 id="3-img中alt和title的区别"><a href="#3-img中alt和title的区别" class="headerlink" title="3.img中alt和title的区别"></a>3.img中alt和title的区别</h4><blockquote><p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化</p></blockquote><blockquote><p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p></blockquote><h4 id="4-用纯CSS创建一个三角形"><a href="#4-用纯CSS创建一个三角形" class="headerlink" title="4.用纯CSS创建一个三角形"></a>4.用纯CSS创建一个三角形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line">        border-top: 40px solid transparent;</span><br><span class="line">        border-left: 40px solid transparent;</span><br><span class="line">        border-right: 40px solid transparent;</span><br><span class="line">        border-bottom: 40px solid #ff0000;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-如何理解CSS的盒子模型？"><a href="#5-如何理解CSS的盒子模型？" class="headerlink" title="5.如何理解CSS的盒子模型？"></a>5.如何理解CSS的盒子模型？</h4><blockquote><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p></blockquote><blockquote><p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p></blockquote><h4 id="6-如何让一个div水平居中"><a href="#6-如何让一个div水平居中" class="headerlink" title="6.如何让一个div水平居中"></a>6.如何让一个div水平居中</h4><blockquote><p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p></blockquote><blockquote><p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p></blockquote><h4 id="7-如何让一个div水平垂直居中"><a href="#7-如何让一个div水平垂直居中" class="headerlink" title="7.如何让一个div水平垂直居中"></a>7.如何让一个div水平垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">position: relative / fixed; /* 相对定位或绝对定位均可 */</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-top:-150px;</span><br><span class="line">margin-left:-250px;</span><br><span class="line"> 外边距为自身宽高的一半 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-items: center; /* 垂直居中 */</span><br><span class="line">justify-content: center; /* 水平居中 */</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">width: 100px; /* 可省 */</span><br><span class="line">height: 100px; /* 可省 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-如何清除浮动？"><a href="#8-如何清除浮动？" class="headerlink" title="8.如何清除浮动？"></a>8.如何清除浮动？</h4><blockquote><p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;}</p></blockquote><blockquote><p>给浮动元素父级设置高度</p></blockquote><blockquote><p>父级同时浮动（需要给父级同级元素添加浮动）</p></blockquote><blockquote><p>父级设置成inline-block，其margin: 0 auto居中方式失效</p></blockquote><blockquote><p>给父级添加overflow:hidden 清除浮动方法</p></blockquote><blockquote><p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float_div:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">clear:both;</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">overflow:hidden;</span><br><span class="line">visibility:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.float_div&#123;</span><br><span class="line">zoom:1</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-css3实现三栏布局，左右固定，中间自适应"><a href="#9-css3实现三栏布局，左右固定，中间自适应" class="headerlink" title="9.css3实现三栏布局，左右固定，中间自适应"></a>9.css3实现三栏布局，左右固定，中间自适应</h4><blockquote><p>圣杯布局/双飞翼布局</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle,</span><br><span class="line">        .left,</span><br><span class="line">        .right &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">            min-height: 130px;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            padding: 0 220px 0 200px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            left: -200px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            margin-left: -220px;</span><br><span class="line">            right: -220px;</span><br><span class="line">            width: 220px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            background: blue;</span><br><span class="line">            word-break: break-all;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&apos;container&apos;&gt;</span><br><span class="line">        &lt;div class=&apos;middle&apos;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&apos;left&apos;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&apos;right&apos;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-display-none-和-visibility-hidden的区别"><a href="#10-display-none-和-visibility-hidden的区别" class="headerlink" title="10.display:none 和 visibility: hidden的区别"></a>10.display:none 和 visibility: hidden的区别</h4><blockquote><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p></blockquote><blockquote><p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p></blockquote><h4 id="11-CSS中-link-和-import-的区别是？"><a href="#11-CSS中-link-和-import-的区别是？" class="headerlink" title="11.CSS中 link 和@import 的区别是？"></a>11.CSS中 link 和@import 的区别是？</h4><blockquote><p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p></blockquote><blockquote><p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p></blockquote><blockquote><p>link方式的样式的权重 高于@import的权重.</p></blockquote><h4 id="12-position的absolute与fixed共同点与不同点"><a href="#12-position的absolute与fixed共同点与不同点" class="headerlink" title="12.position的absolute与fixed共同点与不同点"></a>12.position的absolute与fixed共同点与不同点</h4><blockquote><p>共同点： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上</p></blockquote><blockquote><p>不同点： absolute的”根元素“是可以设置的 fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p></blockquote><h4 id="13-transition和animation的区别"><a href="#13-transition和animation的区别" class="headerlink" title="13..transition和animation的区别"></a>13..transition和animation的区别</h4><blockquote><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性， 而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p></blockquote><blockquote><p>transition 规定动画的名字 规定完成过渡效果需要多少秒或毫秒 规定速度效果 定义过渡效果何时开始 animation 指定要绑定到选择器的关键帧的名称</p></blockquote><h4 id="14-CSS优先级"><a href="#14-CSS优先级" class="headerlink" title="14.CSS优先级"></a>14.CSS优先级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">不同级别：总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</span><br><span class="line">1.属性后面加!import 会覆盖页面内任何位置定义的元素样式</span><br><span class="line">2.作为style属性写在元素内的样式</span><br><span class="line">3.id选择器</span><br><span class="line">4.类选择器</span><br><span class="line">5.标签选择器</span><br><span class="line">6.通配符选择器（*）</span><br><span class="line">7.浏览器自定义或继承</span><br><span class="line">**同一级别：后写的会覆盖先写的**</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p></blockquote><h4 id="15-雪碧图："><a href="#15-雪碧图：" class="headerlink" title="15.雪碧图："></a>15.雪碧图：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        多个图片集成在一个图片中的图</span><br><span class="line">使用雪碧图可以减少网络请求的次数，加快允许的速度</span><br><span class="line">通过background-position，去定位图片在屏幕的哪个位置</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="二、JS问题"><a href="#二、JS问题" class="headerlink" title="二、JS问题"></a>二、JS问题</h1><h4 id="1-typeof和instance-of-检测数据类型有什么区别？"><a href="#1-typeof和instance-of-检测数据类型有什么区别？" class="headerlink" title="1.typeof和instance of 检测数据类型有什么区别？"></a>1.typeof和instance of 检测数据类型有什么区别？</h4><blockquote><p>相同点： 都常用来判断一个变量是否为空，或者是什么类型的。</p></blockquote><blockquote><p>不同点： typeof 返回值是一个字符串，用来说明变量的数据类型 instanceof 用于判断一个变量是否属于某个对象的实例.</p></blockquote><h4 id="16-使元素消失的方法"><a href="#16-使元素消失的方法" class="headerlink" title="16.使元素消失的方法"></a>16.使元素消失的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visibility:hidden、display:none、z-index=-1、opacity：0</span><br><span class="line">1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发</span><br><span class="line">2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</span><br><span class="line">3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="谈一谈深克隆和浅克隆？"><a href="#谈一谈深克隆和浅克隆？" class="headerlink" title=".谈一谈深克隆和浅克隆？"></a>.谈一谈深克隆和浅克隆？</h4><blockquote><p>浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p></blockquote><blockquote><p>深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()</p></blockquote><h4 id="3-es6的新特性都有哪些？"><a href="#3-es6的新特性都有哪些？" class="headerlink" title="3.es6的新特性都有哪些？"></a>3.es6的新特性都有哪些？</h4><blockquote><p>let定义块级作用域变量 没有变量的提升，必须先声明后使用 let声明的变量，不能与前面的let，var，conset声明的变量重名</p></blockquote><blockquote><p>const 定义只读变量 const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改 const声明变量也是一个块级作用域变量 const声明的变量没有“变量的提升”，必须先声明后使用 const声明的变量不能与前面的let， var ， const声明的变量重 const定义的对象\数组中的属性值可以修改,基础数据类型不可以</p></blockquote><blockquote><p>ES6可以给形参函数设置默认值</p></blockquote><blockquote><p>在数组之前加上三个点（…）展开运算符</p></blockquote><blockquote><p>数组的解构赋值、对象的解构赋值</p></blockquote><blockquote><p>箭头函数的特点 箭头函数相当于匿名函数，是不能作为构造函数的，不能被new 箭头函数没有arguments实参集合,取而代之用…剩余运算符解决 箭头函数没有自己的this。他的this是继承当前上下文中的this 箭头函数没有函数原型 箭头函数不能当做Generator函数，不能使用yield关键字 不能使用call、apply、bind改变箭头函数中this指向 Set数据结构，数组去重</p></blockquote><h4 id="4-和-区别是什么？"><a href="#4-和-区别是什么？" class="headerlink" title="4.==和===区别是什么？"></a>4.==和===区别是什么？</h4><blockquote><p>=赋值</p></blockquote><blockquote><p>==返回一个布尔值；相等返回true，不相等返回false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址</p></blockquote><blockquote><p>=== 只要数据类型不一样，就返回false；</p></blockquote><h4 id="5-常见的设计模式有哪些？"><a href="#5-常见的设计模式有哪些？" class="headerlink" title="5.常见的设计模式有哪些？"></a>5.常见的设计模式有哪些？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、js工厂模式</span><br><span class="line">2、js构造函数模式</span><br><span class="line">3、js原型模式</span><br><span class="line">4、构造函数+原型的js混合模式</span><br><span class="line">5、构造函数+原型的动态原型模式</span><br><span class="line">6、观察者模式</span><br><span class="line">7、发布订阅模式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-call-bind-apply-的区别？"><a href="#6-call-bind-apply-的区别？" class="headerlink" title="6.call bind apply 的区别？"></a>6.call bind apply 的区别？</h4><blockquote><p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p></blockquote><blockquote><p>call()和apply()的区别就在于，两者之间的参数。</p></blockquote><blockquote><p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p></blockquote><blockquote><p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是 直接执行该函数。他的参数和call()相同。</p></blockquote><h4 id="7-js继承方式有哪些？"><a href="#7-js继承方式有哪些？" class="headerlink" title="7.js继承方式有哪些？"></a>7.js继承方式有哪些？</h4><blockquote><p>原型链继承 核心： 将父类的实例作为子类的原型</p></blockquote><blockquote><p>构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p></blockquote><blockquote><p>实例继承 核心：为父类实例添加新特性，作为子类实例返回</p></blockquote><blockquote><p>拷贝继承</p></blockquote><blockquote><p>组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用</p></blockquote><blockquote><p>寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点</p></blockquote><h4 id="8-你怎样看待闭包？"><a href="#8-你怎样看待闭包？" class="headerlink" title="8.你怎样看待闭包？"></a>8.你怎样看待闭包？</h4><blockquote><p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p></blockquote><h4 id="9-你是如何理解原型和原型链的？"><a href="#9-你是如何理解原型和原型链的？" class="headerlink" title="9.你是如何理解原型和原型链的？"></a>9.你是如何理解原型和原型链的？</h4><blockquote><p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 <strong>proto</strong>存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过<strong>proto</strong>向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p></blockquote><h4 id="10-浏览器渲染的主要流程是什么"><a href="#10-浏览器渲染的主要流程是什么" class="headerlink" title="10.浏览器渲染的主要流程是什么?"></a>10.浏览器渲染的主要流程是什么?</h4><blockquote><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p></blockquote><h4 id="11-从输入url地址到页面相应都发生了什么？"><a href="#11-从输入url地址到页面相应都发生了什么？" class="headerlink" title="11.从输入url地址到页面相应都发生了什么？"></a>11.从输入url地址到页面相应都发生了什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器的地址栏输入URL并按下回车。</span><br><span class="line">2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。</span><br><span class="line">4、根据IP建立TCP连接（三次握手）。</span><br><span class="line">5、HTTP发起请求。</span><br><span class="line">6、服务器处理请求，浏览器接收HTTP响应。</span><br><span class="line">7、渲染页面，构建DOM树。</span><br><span class="line">8、关闭TCP连接（四次挥手）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="12-session、cookie、localStorage的区别"><a href="#12-session、cookie、localStorage的区别" class="headerlink" title="12.session、cookie、localStorage的区别"></a>12.session、cookie、localStorage的区别</h4><blockquote><p>相同点 都是保存在浏览器端，且同源的。</p></blockquote><blockquote><p>不同点</p></blockquote><ul><li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li><li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li><li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li></ul><h4 id="13-js中跨域方法"><a href="#13-js中跨域方法" class="headerlink" title="13.js中跨域方法"></a>13.js中跨域方法</h4><blockquote><p>同源策略（协议+端口号+域名要相同）</p></blockquote><blockquote><p>1、jsonp跨域(只能解决get） 原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p><blockquote><p>步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据</p></blockquote></blockquote><blockquote><p>2、document.domain 基础域名相同 子域名不同</p></blockquote><blockquote><p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></blockquote><blockquote><p>4、服务器设置对CORS的支持 原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></blockquote><blockquote><p>5、利用h5新特性window.postMessage()</p></blockquote><h4 id="14-前端有哪些页面优化方法"><a href="#14-前端有哪些页面优化方法" class="headerlink" title="14.前端有哪些页面优化方法?"></a>14.前端有哪些页面优化方法?</h4><ul><li>减少 HTTP请求数</li><li>从设计实现层面简化页面</li><li>合理设置 HTTP缓存</li><li>资源合并与压缩</li><li>合并 CSS图片，减少请求数的又一个好办法。</li><li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li><li>多图片网页使用图片懒加载。</li><li>在js中尽量减少闭包的使用</li><li>尽量合并css和js文件</li><li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li><li>减少对DOM的操作</li><li>在JS中避免“嵌套循环”和 “死循环”</li><li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li></ul><h4 id="15-Ajax的四个步骤"><a href="#15-Ajax的四个步骤" class="headerlink" title="15.Ajax的四个步骤"></a>15.Ajax的四个步骤</h4><blockquote><p>1.创建ajax实例</p></blockquote><blockquote><p>2.执行open 确定要访问的链接 以及同步异步</p></blockquote><blockquote><p>3.监听请求状态</p></blockquote><blockquote><p>4.发送请求</p></blockquote><h4 id="16-数组去重的方法"><a href="#16-数组去重的方法" class="headerlink" title="16.数组去重的方法"></a>16.数组去重的方法</h4><blockquote><p>ES6的set对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    var arr2 = arr.sort();</span><br><span class="line">    var res = [arr2[0]];</span><br><span class="line">    for(var i=1;i&lt;arr2.length;i++)&#123;</span><br><span class="line">        if(arr2[i] !== res[res.length-1])&#123;</span><br><span class="line">        res.push(arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">利用下标查询</span><br><span class="line"> function unique(arr)&#123;</span><br><span class="line">    var newArr = [arr[0]];</span><br><span class="line">    for(var i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">        newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return newArr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="17-ajax中get和post请求的区别"><a href="#17-ajax中get和post请求的区别" class="headerlink" title="17.ajax中get和post请求的区别"></a>17.ajax中get和post请求的区别</h4><ul><li>get 一般用于获取数据</li><li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li><li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li><li>get安全性较低</li><li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li><li>post 一般用于发送数据</li><li>post传递参数，需要把参数放进请求体中，发送给服务器；</li><li>post请求参数放进了请求体中，对大小没有要求；</li><li>post安全性比较高；</li><li>post请求不会走缓存；</li><li></li></ul><h4 id="18-ajax的状态码"><a href="#18-ajax的状态码" class="headerlink" title="18.ajax的状态码"></a>18.ajax的状态码</h4><blockquote><p>2开头</p></blockquote><ul><li>200 : 代表请求成功；</li></ul><blockquote><p>3开头</p></blockquote><ul><li>301 : 永久重定向；</li><li>302: 临时转移</li><li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li><li>307:临时重定向</li></ul><blockquote><p>以4开头的都是客户端的问题；</p></blockquote><ul><li>400 :数据/格式错误</li><li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li><li>404 : 路径错误，找不到文件</li></ul><blockquote><p>以5开头都是服务端的问题</p></blockquote><ul><li>500 : 服务器的问题</li><li>503: 超负荷；</li></ul><h4 id="19-移动端的兼容问题"><a href="#19-移动端的兼容问题" class="headerlink" title="19.移动端的兼容问题"></a>19.移动端的兼容问题</h4><ul><li><p>给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend</p></li><li><p>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。 用fastclick，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">github.com/ftlabs/fast…</a> 用preventDefault阻止a标签的click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}</p></li><li><p>设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</p></li><li><p>圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</p></li><li><p>设置用户截止缩放，一般写视口的时候就已经写好了。</p></li><li></li></ul><h4 id="20-JS中同步和异步-以及js的事件流"><a href="#20-JS中同步和异步-以及js的事件流" class="headerlink" title="20.JS中同步和异步,以及js的事件流"></a>20.JS中同步和异步,以及js的事件流</h4><blockquote><p>同步：在同一时间内做一件事情</p></blockquote><blockquote><p>异步：在同一时间内做多个事情 JS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p></blockquote><h4 id="21-JS中常见的异步任务"><a href="#21-JS中常见的异步任务" class="headerlink" title="21.JS中常见的异步任务"></a>21.JS中常见的异步任务</h4><blockquote><p>定时器、ajax、事件绑定、回调函数、async await、promise</p></blockquote><h4 id="22-TCP的三次握手和四次挥手"><a href="#22-TCP的三次握手和四次挥手" class="headerlink" title="22.TCP的三次握手和四次挥手"></a>22.TCP的三次握手和四次挥手</h4><blockquote><p>三次握手</p></blockquote><ul><li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li><li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li><li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li></ul><blockquote><p>四次挥手</p></blockquote><ul><li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li><li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li><li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li><li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li></ul><h4 id="23-为什么建立连接是三次握手，而断开连接是四次挥手呢"><a href="#23-为什么建立连接是三次握手，而断开连接是四次挥手呢" class="headerlink" title="23.为什么建立连接是三次握手，而断开连接是四次挥手呢?"></a>23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4><blockquote><blockquote><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote></blockquote><h4 id="24-DOM-diff原理"><a href="#24-DOM-diff原理" class="headerlink" title="24.DOM diff原理"></a>24.DOM diff原理</h4><blockquote><ul><li>如果元素类型发生变化，直接替换</li><li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li></ul></blockquote><h4 id="25-作用域"><a href="#25-作用域" class="headerlink" title="25.作用域"></a>25.作用域</h4><blockquote><p>全局作用域</p></blockquote><ul><li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个window对象 window是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下） 如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被var过，那么存储值是undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li></ul><blockquote><p>私有作用域</p></blockquote><ul><li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li></ul><blockquote><p>块级作用域</p></blockquote><ul><li>es6中新引入的一种作用域 在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错） 作用域链</li></ul><blockquote><p>上级作用域</p></blockquote><ul><li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li></ul><h4 id="26-Promise处理异步"><a href="#26-Promise处理异步" class="headerlink" title="26.Promise处理异步"></a>26.Promise处理异步</h4><blockquote><p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行 Promise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法) then()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject ajax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p></blockquote><h4 id="27-map和forEach的区别"><a href="#27-map和forEach的区别" class="headerlink" title="27.map和forEach的区别"></a>27.map和forEach的区别</h4><blockquote><p>相同点</p></blockquote><ul><li>都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组</li></ul><blockquote><p>不同点</p></blockquote><ul><li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li></ul><blockquote><blockquote><p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p></blockquote></blockquote><h4 id="28-async-await函数"><a href="#28-async-await函数" class="headerlink" title="28.async await函数"></a>28.async await函数</h4><blockquote><p>async/await函数是异步代码的新方式</p></blockquote><blockquote><p>async/await是基于promise实现的</p></blockquote><blockquote><p>async/await使异步代码更像同步代码</p></blockquote><blockquote><p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p></blockquote><blockquote><p>默认返回一个promise实例，不能被改变</p></blockquote><blockquote><p>await下面的代码是异步，后面的代码是同步的</p></blockquote><h4 id="29-this指向"><a href="#29-this指向" class="headerlink" title="29.this指向"></a>29.this指向</h4><blockquote><ul><li>全局作用域下的this指向window</li><li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li><li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li><li>自执行函数中的this永远指向window</li><li>定时器中函数的this指向window</li><li>构造函数中的this指向当前的实例</li><li>call、apply、bind可以改变函数的this指向</li><li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li></ul></blockquote><h4 id="30-原型"><a href="#30-原型" class="headerlink" title="30.原型"></a>30.原型</h4><blockquote><blockquote><p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象 prototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p></blockquote></blockquote><h4 id="31-异步回调（如何解决回调地狱）"><a href="#31-异步回调（如何解决回调地狱）" class="headerlink" title="31.异步回调（如何解决回调地狱）"></a>31.异步回调（如何解决回调地狱）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">promise、generator、async/await</span><br><span class="line"></span><br><span class="line">promise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理</span><br><span class="line">  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱</span><br><span class="line">  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）</span><br><span class="line">  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败</span><br><span class="line">promise.all() 里面状态都改变，那就会输出，得到一个数组</span><br><span class="line">promise.race() 里面只有一个状态变为rejected或者fulfilled即输出</span><br><span class="line">promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="32-前端事件流"><a href="#32-前端事件流" class="headerlink" title="32.前端事件流"></a>32.前端事件流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</span><br><span class="line">  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。</span><br><span class="line">      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。</span><br><span class="line">      3、冒泡阶段：事件又传播回文档</span><br><span class="line">   阻止冒泡事件event.stopPropagation()</span><br><span class="line">  function stopBubble(e) &#123;</span><br><span class="line">    if (e &amp;&amp; e.stopPropagation) &#123; // 如果提供了事件对象event 这说明不是IE浏览器</span><br><span class="line">      e.stopPropagation()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      window.event.cancelBubble = true //IE方式阻止冒泡</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   阻止默认行为event.preventDefault()</span><br><span class="line"> function stopDefault(e) &#123;</span><br><span class="line">    if (e &amp;&amp; e.preventDefault) &#123;</span><br><span class="line">      e.preventDefault()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // IE浏览器阻止函数器默认动作的行为</span><br><span class="line">      window.event.returnValue = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="33-事件如何先捕获后冒泡？"><a href="#33-事件如何先捕获后冒泡？" class="headerlink" title="33.事件如何先捕获后冒泡？"></a>33.事件如何先捕获后冒泡？</h4><blockquote><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p></blockquote><ul><li>哪些事件不支持冒泡事件：鼠标事件：mouserleave mouseenter 焦点事件：blur focus UI事件：scroll resize</li></ul><h4 id="34-如何判断一个变量是对象还是数组（prototype-toString-call-）。"><a href="#34-如何判断一个变量是对象还是数组（prototype-toString-call-）。" class="headerlink" title="34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。"></a>34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。</p></blockquote><blockquote><p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p></blockquote><blockquote><p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p></blockquote><blockquote><p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p></blockquote><blockquote><p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p></blockquote><h4 id="35-setTimeout-和-setInterval的机制"><a href="#35-setTimeout-和-setInterval的机制" class="headerlink" title="35.setTimeout 和 setInterval的机制"></a>35.setTimeout 和 setInterval的机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的</span><br><span class="line">待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="36-splice和slice、map和forEach、-filter-、reduce-的区别"><a href="#36-splice和slice、map和forEach、-filter-、reduce-的区别" class="headerlink" title="36.splice和slice、map和forEach、 filter()、reduce()的区别"></a>36.splice和slice、map和forEach、 filter()、reduce()的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，</span><br><span class="line"> 包含从start到end（不包含该元素）的数组方法</span><br><span class="line">注意：该方法不会更新原数组，而是返回一个子数组</span><br><span class="line"> 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）</span><br><span class="line">splice(index, howmany,item1,...itemx)</span><br><span class="line">·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置</span><br><span class="line">·howmany参数：必须，要删除的数量，</span><br><span class="line">·item1..itemx:可选，向数组添加新项目</span><br><span class="line">3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据</span><br><span class="line">4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素</span><br><span class="line">5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值</span><br><span class="line">6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="VUE问题"><a href="#VUE问题" class="headerlink" title="VUE问题"></a>VUE问题</h1><h4 id="1-聊聊对vue的理解"><a href="#1-聊聊对vue的理解" class="headerlink" title="1.聊聊对vue的理解"></a>1.聊聊对vue的理解</h4><blockquote><p>vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p></blockquote><h4 id="2-V-model的原理是什么？"><a href="#2-V-model的原理是什么？" class="headerlink" title="2.V-model的原理是什么？"></a>2.V-model的原理是什么？</h4><blockquote><p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事</p><ul><li>原理 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li></ul></blockquote><h4 id="3-谈谈对生命周期的理解"><a href="#3-谈谈对生命周期的理解" class="headerlink" title="3.谈谈对生命周期的理解"></a>3.谈谈对生命周期的理解</h4><ul><li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li><li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li><li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li><li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li><li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li><li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li><li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li><li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li></ul><h4 id="4-VUE和REACT有什么区别？"><a href="#4-VUE和REACT有什么区别？" class="headerlink" title="4.VUE和REACT有什么区别？"></a>4.VUE和REACT有什么区别？</h4><blockquote><p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p></blockquote><blockquote><p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p></blockquote><h4 id="5-vuex的流程"><a href="#5-vuex的流程" class="headerlink" title="5.vuex的流程"></a>5.vuex的流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。</span><br><span class="line">mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中</span><br><span class="line">通过mapGetter来动态获取state中的值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-vuex有哪几种状态和属性"><a href="#6-vuex有哪几种状态和属性" class="headerlink" title="6.vuex有哪几种状态和属性"></a>6.vuex有哪几种状态和属性</h4><blockquote><ul><li>state中保存着共有数据，数据是响应式的</li><li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li><li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li><li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li><li>modules：模块化vuex</li></ul></blockquote><h4 id="7-vue路由的两种模式"><a href="#7-vue路由的两种模式" class="headerlink" title="7.vue路由的两种模式"></a>7.vue路由的两种模式</h4><blockquote><ul><li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li><li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li></ul><p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p></blockquote><h4 id="8-vue中-key-值的作用"><a href="#8-vue中-key-值的作用" class="headerlink" title="8.vue中 key 值的作用"></a>8.vue中 key 值的作用</h4><blockquote><p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p></blockquote><blockquote><p>key的作用主要是为了高效的更新虚拟DOM。</p></blockquote><h4 id="9-route和-router的区别"><a href="#9-route和-router的区别" class="headerlink" title="9$route和$router的区别"></a>9<code>$route</code>和<code>$router</code>的区别</h4><blockquote><ul><li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li><li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul></blockquote><h4 id="10-vue-router守卫"><a href="#10-vue-router守卫" class="headerlink" title="10.vue-router守卫"></a>10.vue-router守卫</h4><blockquote><ul><li>导航守卫 router.beforeEach 全局前置守卫</li></ul></blockquote><ul><li>to: Route: 即将要进入的目标（路由对象）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。</li><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// main.js 入口文件</span><br><span class="line">    import router from &apos;./router&apos;; // 引入路由</span><br><span class="line">    router.beforeEach((to, from, next) =&gt; &#123; </span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">    router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">    router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">      console.log(&apos;afterEach 全局后置钩子&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/foo&apos;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">    // 比如还未保存草稿，或者在用户离开前，</span><br><span class="line">    将setInterval销毁，防止离开之后，定时器还在调用。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="11-axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#11-axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="11.axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4><blockquote><p>请求后台资源的模块。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios -S装好</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。 js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p></blockquote><h4 id="12-vue修饰符"><a href="#12-vue修饰符" class="headerlink" title="12.vue修饰符"></a>12.vue修饰符</h4><ul><li>stop：阻止事件的冒泡</li><li>prevent：阻止事件的默认行为</li><li>once：只触发一次</li><li>self：只触发自己的事件行为时，才会执行</li></ul><h4 id="13-vue项目中的性能优化"><a href="#13-vue项目中的性能优化" class="headerlink" title="13.vue项目中的性能优化"></a>13.vue项目中的性能优化</h4><blockquote><p>1.不要在模板里面写过多表达式</p></blockquote><blockquote><p>2.循环调用子组件时添加key</p></blockquote><blockquote><p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p></blockquote><blockquote><p>4.尽量少用float，可以用flex</p></blockquote><blockquote><p>5.按需加载，可以用require或者import()按需加载需要的组件</p></blockquote><blockquote><p>6.路由懒加载</p></blockquote><h4 id="14-vue-extend和vue-component"><a href="#14-vue-extend和vue-component" class="headerlink" title="14.vue.extend和vue.component"></a>14.vue.extend和vue.component</h4><blockquote><ul><li>extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li><li>Vue.component 你可以创建 ，也可以取组件。</li></ul></blockquote><h3 id="常见的兼容问题"><a href="#常见的兼容问题" class="headerlink" title="常见的兼容问题"></a>常见的兼容问题</h3><blockquote><p>png24位的图片在iE6浏览器上出现背景 解决方案是做成PNG8.也可以引用一段脚本处理.</p></blockquote><blockquote><p>浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><blockquote><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p></blockquote><blockquote><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p></blockquote><h1 id="React问题"><a href="#React问题" class="headerlink" title="React问题"></a>React问题</h1><h4 id="1-react和vue的区别"><a href="#1-react和vue的区别" class="headerlink" title="1.react和vue的区别"></a>1.react和vue的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   =&gt;  相同点：</span><br><span class="line">1.数据驱动页面，提供响应式的试图组件</span><br><span class="line">2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范</span><br><span class="line">3.数据流动单向，都支持服务器的渲染SSR</span><br><span class="line">4.都有支持native的方法，react有React native， vue有wexx</span><br><span class="line">=&gt;  不同点：</span><br><span class="line">1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的</span><br><span class="line">2.数据渲染：大规模的数据渲染，react更快</span><br><span class="line">3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目</span><br><span class="line">4.开发风格：react推荐做法jsx + inline style把html和css都写在js了</span><br><span class="line">    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-redux中的reducer（纯函数）"><a href="#2-redux中的reducer（纯函数）" class="headerlink" title="2.redux中的reducer（纯函数）"></a>2.redux中的reducer（纯函数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）</span><br><span class="line">更新state(这个state可以理解为上下累加器的结果）</span><br><span class="line">每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是&apos;自身消减&apos;(reduce),</span><br><span class="line">进而返回最新的state,这也就是典型reduce函数的用法：state -&gt;  action -&gt;  state</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3-react的refs"><a href="#3-react的refs" class="headerlink" title="3.react的refs"></a>3.react的refs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，</span><br><span class="line">它将接受地城dom元素或组件的已挂在实例，作为第一个参数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4-react中的keys"><a href="#4-react中的keys" class="headerlink" title="4.react中的keys"></a>4.react中的keys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-React的生命周期"><a href="#5-React的生命周期" class="headerlink" title="5.React的生命周期"></a>5.React的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">三个状态：Mounting(已插入真实的DOM）</span><br><span class="line">  Updating(正在被重新渲染)</span><br><span class="line">  Unmounting(已移除真实的DOM)</span><br><span class="line">componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，</span><br><span class="line">componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-React子组件向父组件传值"><a href="#6-React子组件向父组件传值" class="headerlink" title="6.React子组件向父组件传值"></a>6.React子组件向父组件传值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…"><a href="#7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…" class="headerlink" title="7.为什么虚拟DOM会提高性能 www.zhihu.com/question/29…"></a>7.为什么虚拟DOM会提高性能 <a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">www.zhihu.com/question/29…</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能</span><br><span class="line">具体实现步骤：</span><br><span class="line">·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中</span><br><span class="line">        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异</span><br><span class="line">·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-diff算法"><a href="#8-diff算法" class="headerlink" title="8.diff算法"></a>8.diff算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记</span><br><span class="line">3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面</span><br><span class="line">Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用</span><br><span class="line">react只会匹配相同的class的component（这里的class指的是组件的名字）</span><br><span class="line">合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制</span><br><span class="line">4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-简述下flux的思想"><a href="#9-简述下flux的思想" class="headerlink" title="9.简述下flux的思想"></a>9.简述下flux的思想</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flux的最大特点，就是数据的‘单向流动’</span><br><span class="line">1.用户访问View</span><br><span class="line">2.View发出用户的Action</span><br><span class="line">3.Dispatcher收到Action,要求state进行相应的更新</span><br><span class="line">4.store更新后，发出一个‘change’事件后，更新页面</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-reac性能优化是哪个周期函"><a href="#10-reac性能优化是哪个周期函" class="headerlink" title="10.reac性能优化是哪个周期函"></a>10.reac性能优化是哪个周期函</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，</span><br><span class="line">如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="11-react怎么划分业务组件和技术组件"><a href="#11-react怎么划分业务组件和技术组件" class="headerlink" title="11.react怎么划分业务组件和技术组件"></a>11.react怎么划分业务组件和技术组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根据组件的职责通常把组件分为UI组件和容器组件</span><br><span class="line">UI组件负责UI的呈现，容器组件负责管理数据和逻辑</span><br><span class="line">两者通过React-redux提供connect方法联系起来</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="12-setState"><a href="#12-setState" class="headerlink" title="12.setState"></a>12.setState</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列</span><br><span class="line">而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值</span><br><span class="line">那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误</span><br><span class="line"></span><br><span class="line">同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state</span><br><span class="line"></span><br><span class="line">同步更新state:</span><br><span class="line">setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。</span><br><span class="line">第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行</span><br><span class="line">也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步</span><br><span class="line"></span><br><span class="line">例子：componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">fetch(&apos;https://test.com&apos;)</span><br><span class="line">    </span><br><span class="line">.then((res) =&gt; res.json())</span><br><span class="line">    </span><br><span class="line">.then(</span><br><span class="line">    (data) =&gt; &#123;</span><br><span class="line">this.setState(&#123; data:data &#125;);</span><br><span class="line">StatusBar.setNetworkActivityIndicatorVisible(false);</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h4 id="一、webpack打包文件体积过大？（最终打包为一个js文件）"><a href="#一、webpack打包文件体积过大？（最终打包为一个js文件）" class="headerlink" title="一、webpack打包文件体积过大？（最终打包为一个js文件）"></a>一、webpack打包文件体积过大？（最终打包为一个js文件）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.异步加载模块</span><br><span class="line">2.提取第三库</span><br><span class="line">3.代码压缩</span><br><span class="line">4.去除不必要的插件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="二、如何优化webpack构建的性能"><a href="#二、如何优化webpack构建的性能" class="headerlink" title="二、如何优化webpack构建的性能"></a>二、如何优化webpack构建的性能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积</span><br><span class="line"> 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理</span><br><span class="line"> 3.对一些组件库采用按需加载，避免无用的代码</span><br><span class="line">二、减少目录检索范围</span><br><span class="line"> ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度</span><br><span class="line"></span><br><span class="line">三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三、移动端的性能优化"><a href="#三、移动端的性能优化" class="headerlink" title="三、移动端的性能优化"></a>三、移动端的性能优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  1、首屏加载和按需加载，懒加载</span><br><span class="line">  2、资源预加载</span><br><span class="line">  3、图片压缩处理，使用base64内嵌图片</span><br><span class="line">  4、合理缓存dom对象</span><br><span class="line">  5、使用touchstart代替click（click 300毫秒的延迟）</span><br><span class="line">  6、利用transform:translateZ(0)，开启硬件GUP加速</span><br><span class="line">  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明</span><br><span class="line">  8、使用viewport固定屏幕渲染，加速页面渲染内容</span><br><span class="line">  9、尽量使用事件代理，避免直接事件绑定</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="四、Vue的SPA-如何优化加载速度"><a href="#四、Vue的SPA-如何优化加载速度" class="headerlink" title="四、Vue的SPA 如何优化加载速度"></a>四、Vue的SPA 如何优化加载速度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.减少入口文件体积</span><br><span class="line">2.静态资源本地缓存</span><br><span class="line">3.开启Gzip压缩</span><br><span class="line">4.使用SSR,nuxt.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、移动端300ms延迟"><a href="#五、移动端300ms延迟" class="headerlink" title="五、移动端300ms延迟"></a>五、移动端300ms延迟</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由来：</span><br><span class="line">300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，</span><br><span class="line">当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作</span><br><span class="line">因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕</span><br><span class="line">       </span><br><span class="line">解决方案：1.禁用缩放，设置meta标签 user-scalable=no</span><br><span class="line">  2.fastclick.js</span><br><span class="line">原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即</span><br><span class="line">      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉</span><br><span class="line">fastclick.js还可以解决穿透问题</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、页面的重构；"><a href="#六、页面的重构；" class="headerlink" title="六、页面的重构；"></a>六、页面的重构；</h4><blockquote><p>在不改变外部行为的前提下，简化结构、添加可读性</p></blockquote><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><h4 id="一、状态码："><a href="#一、状态码：" class="headerlink" title="一、状态码："></a>一、状态码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  2XX（成功处理了请求状态）</span><br><span class="line">      200 服务器已经成功处理请求，并提供了请求的网页</span><br><span class="line">      201 用户新建或修改数据成功</span><br><span class="line">      202 一个请求已经进入后台</span><br><span class="line">      204 用户删除成功</span><br><span class="line">  3XX（每次请求使用的重定向不要超过5次）</span><br><span class="line">      304 网页上次请求没有更新，节省带宽和开销</span><br><span class="line">  4XX（表示请求可能出错，妨碍了服务器的处理）</span><br><span class="line">      400 服务器不理解请求的语法</span><br><span class="line">      401 用户没有权限（用户名，密码输入错误）</span><br><span class="line">      403 用户得到授权（401相反），但是访问被禁止</span><br><span class="line">      404 服务器找不到请求的网页，</span><br><span class="line">  5XX（表示服务器在处理请求的时候发生内部错误）</span><br><span class="line">      500 服务器遇到错误，无法完成请求</span><br><span class="line">      503 服务器目前无法使用（超载或停机维护）     </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销"><a href="#二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销" class="headerlink" title="二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销"></a>二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）</span><br><span class="line">2.304是HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件</span><br><span class="line">3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A</span><br><span class="line">并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304</span><br><span class="line"></span><br><span class="line">last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间</span><br><span class="line">客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，</span><br><span class="line">询问该事件之后文件是否被修改，没修改返回304</span><br><span class="line"></span><br><span class="line"> 有了Last-Modified，为什么还要用ETag？</span><br><span class="line">  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）</span><br><span class="line">  2、某些服务器不能精确的得到文件的最后修改时间</span><br><span class="line">  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get</span><br><span class="line"></span><br><span class="line">ETag，为什么还要用Last-Modified？</span><br><span class="line">  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改</span><br><span class="line">  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）</span><br><span class="line">  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三、get-post的区别"><a href="#三、get-post的区别" class="headerlink" title="三、get/post的区别"></a>三、get/post的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中</span><br><span class="line">2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制</span><br><span class="line">3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值</span><br><span class="line">4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="四、http协议的理解"><a href="#四、http协议的理解" class="headerlink" title="四、http协议的理解"></a>四、http协议的理解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议</span><br><span class="line">2.基于TCP/IP通信协议来传递数据（HTML，图片资源）</span><br><span class="line">3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统</span><br><span class="line">4.http请求信息request：</span><br><span class="line">请求行（request line）、请求头部（header）,空行和请求数据四部分构成</span><br><span class="line"></span><br><span class="line">请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</span><br><span class="line">请求头部，用来说明服务器要使用的附加信息</span><br><span class="line">空行，请求头部后面的空行是必须的</span><br><span class="line">请求数据也叫主体，可以添加任意的其他数据。</span><br><span class="line">5.http相应信息Response</span><br><span class="line">状态行、消息报头、空行和响应正文</span><br><span class="line"></span><br><span class="line">状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成</span><br><span class="line">消息报头，用来说明客户端要使用的一些附加信息</span><br><span class="line">空行，消息报头后面的空行是必须的</span><br><span class="line">响应正文，服务器返回给客户端的文本信息。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、http和https"><a href="#五、http和https" class="headerlink" title="五、http和https"></a>五、http和https</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密</span><br><span class="line">http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、http1-0-1-1-2-0的区别"><a href="#六、http1-0-1-1-2-0的区别" class="headerlink" title="六、http1.0 1.1 2.0的区别"></a>六、http1.0 1.1 2.0的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接</span><br><span class="line">节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）</span><br><span class="line">host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</span><br><span class="line"></span><br><span class="line">1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好</span><br><span class="line">2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量</span><br><span class="line">3.多路复用：一个连接可以并发处理多个请求</span><br><span class="line">4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="七、web缓存"><a href="#七、web缓存" class="headerlink" title="七、web缓存"></a>七、web缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本</span><br><span class="line">2.缓存的好处</span><br><span class="line">        （1）减少不必要的请求</span><br><span class="line">    （2）降低服务器的压力，减少服务器的消耗</span><br><span class="line">    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="八、常见的web安全及防护原理"><a href="#八、常见的web安全及防护原理" class="headerlink" title="八、常见的web安全及防护原理"></a>八、常见的web安全及防护原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，</span><br><span class="line">            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，</span><br><span class="line">            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。</span><br><span class="line">防范：1.对用户输入进行校验</span><br><span class="line">       2.不适用动态拼接sql</span><br><span class="line">2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。</span><br><span class="line">        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息</span><br><span class="line">防范：1.尽量采用post而不使用get提交表单</span><br><span class="line">      2.避免cookie中泄漏用户的隐式</span><br><span class="line">3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求</span><br><span class="line">举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据</span><br><span class="line">防范：在客服端页面增加伪随机数，通过验证码</span><br><span class="line">XSS和CSRF的区别：</span><br><span class="line">   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包</span><br><span class="line">   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="九、CDN（内容分发网络）"><a href="#九、CDN（内容分发网络）" class="headerlink" title="九、CDN（内容分发网络）"></a>九、CDN（内容分发网络）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。</span><br><span class="line">2.关键技术：内容存储和分发技术中</span><br><span class="line">3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术</span><br><span class="line">    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十、TCP三次握手-客服端和服务器端都需要确认各自可收发）"><a href="#十、TCP三次握手-客服端和服务器端都需要确认各自可收发）" class="headerlink" title="十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）"></a>十、TCP三次握手 (客服端和服务器端都需要确认各自可收发）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。</span><br><span class="line">第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段</span><br><span class="line">第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段</span><br><span class="line">第三次握手： 服务器端确认客服端收到了自己发送的报文段</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…"><a href="#十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…" class="headerlink" title="十一、从输入url到获取页面的完整过程  blog.csdn.net/samjustin1/…"></a>十一、从输入url到获取页面的完整过程 <a href="https://blog.csdn.net/samjustin1/article/details/52650520" target="_blank" rel="noopener">blog.csdn.net/samjustin1/…</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存</span><br><span class="line">2.浏览器与服务器建立tcp链接（三次握手）</span><br><span class="line">3.浏览器向服务器发送http请求(请求和传输数据）</span><br><span class="line">4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器</span><br><span class="line">5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤</span><br><span class="line">6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print"><a href="#十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print" class="headerlink" title="十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print"></a>十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树</span><br><span class="line">概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树</span><br><span class="line">      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）</span><br><span class="line">      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置</span><br><span class="line">      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点</span><br><span class="line"></span><br><span class="line">重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上</span><br><span class="line">触发重绘的条件：改变元素外观属性。如：color，background-color等</span><br><span class="line">重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观</span><br><span class="line">注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局</span><br><span class="line"></span><br><span class="line">重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。</span><br><span class="line">每个页面都需要一次回流，就是页面第一次渲染的时候</span><br><span class="line"></span><br><span class="line">重排一定会影响重绘，但是重绘不一定会影响重排</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十三、为什么css放在顶部而js写在后面"><a href="#十三、为什么css放在顶部而js写在后面" class="headerlink" title="十三、为什么css放在顶部而js写在后面"></a>十三、为什么css放在顶部而js写在后面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了</span><br><span class="line">2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。</span><br><span class="line">3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验</span><br><span class="line"></span><br><span class="line">但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十四、存储方式与传输方式"><a href="#十四、存储方式与传输方式" class="headerlink" title="十四、存储方式与传输方式"></a>十四、存储方式与传输方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m</span><br><span class="line">2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响</span><br><span class="line">3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）</span><br><span class="line">4.localStroage: h5的本地存储，数据永久保存在客服端</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie，sessionStorage，localStorage"><a href="#cookie，sessionStorage，localStorage" class="headerlink" title="cookie，sessionStorage，localStorage"></a>cookie，sessionStorage，localStorage</h4><p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上 实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象 session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据 2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id sessionStorage，localStorage仅在本地保存 3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB 4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭 sessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储） localStorage始终有效</p><p>SessionStorage和localStorage区别： 1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中） 并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存 2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p><h4 id="token、cookie、session三者的理解？？？！！！"><a href="#token、cookie、session三者的理解？？？！！！" class="headerlink" title="token、cookie、session三者的理解？？？！！！"></a>token、cookie、session三者的理解？？？！！！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）</span><br><span class="line">    用户身份的验证方式    </span><br><span class="line"></span><br><span class="line">2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名</span><br><span class="line">    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）</span><br><span class="line"></span><br><span class="line">3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）</span><br><span class="line">    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）"><a href="#基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）" class="headerlink" title="基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）"></a>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  1、用户通过用户名和密码发送请求</span><br><span class="line">  2、服务器端验证</span><br><span class="line">  3、服务器端返回一个带签名的token，给客户端</span><br><span class="line">  4、客户端储存token，并且每次用于发送请求</span><br><span class="line">  5、服务器验证token并且返回数据</span><br><span class="line">  每一次请求都需要token</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</span><br><span class="line">  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="session与token区别"><a href="#session与token区别" class="headerlink" title="session与token区别"></a>session与token区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App</span><br><span class="line">  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，</span><br><span class="line">     token不能转移到其他的App，也不能转到其他用户上。（适用于App）</span><br><span class="line">  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"><a href="#Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）" class="headerlink" title="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"></a>Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）</span><br><span class="line">  2、安全性问题。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>一、观察者模式：<a href="https://juejin.im/post/5a14e9edf265da4312808d86" target="_blank" rel="noopener">juejin.im/post/5a14e9…</a> <a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">juejin.im/post/5af05d…</a> 在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系 简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p></blockquote><blockquote><p>二、发布-订阅者 有一个信息中介，过滤 耦合性低 它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p></blockquote><ul><li>-两者的区别： 1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信 2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。 3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（） 4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li></ul><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h4 id="一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…"><a href="#一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…" class="headerlink" title="一、两个栈实现一个队列，两个队列实现一个栈 www.cnblogs.com/MrListening…"></a>一、两个栈实现一个队列，两个队列实现一个栈 <a href="https://www.cnblogs.com/MrListening/p/5697459.html" target="_blank" rel="noopener">www.cnblogs.com/MrListening…</a></h4><h4 id="二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…"><a href="#二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…" class="headerlink" title="二、红黑树（解决二叉树依次插入多个节点时的线型排列） juejin.im/post/5a27c6…"></a>二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a href="https://juejin.im/post/5a27c6946fb9a04509096248" target="_blank" rel="noopener">juejin.im/post/5a27c6…</a></h4><h4 id="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…"><a href="#三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…" class="headerlink" title="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin.im/post/5a2ff8…"></a>三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a href="https://juejin.im/post/5a2ff8c651882533d0230a85" target="_blank" rel="noopener">juejin.im/post/5a2ff8…</a></h4><h4 id="四、十大排序"><a href="#四、十大排序" class="headerlink" title="四、十大排序"></a>四、十大排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。</span><br><span class="line">  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个</span><br><span class="line">    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</span><br><span class="line">    3.针对所有的元素重复以上的步骤，除了最后一个</span><br><span class="line">    4.重复步骤1-3，直到排序完成。</span><br><span class="line">2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾</span><br><span class="line">  实现过程：</span><br><span class="line"></span><br><span class="line">3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入</span><br><span class="line">  实现过程：1.从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line">    2.取出下一个元素，在已排序的元素序列中冲后向前扫描</span><br><span class="line">    3.如果该元素（以排序）大于新元素，将元素向后移一位</span><br><span class="line">    4.在取出一个元素，比较之前的，直到找到自己合适的位置</span><br><span class="line"></span><br><span class="line">4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序</span><br><span class="line"></span><br><span class="line">1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现</span><br><span class="line">  实现过程：1.从数组中挑出一个元素，成为一个基准</span><br><span class="line">    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）</span><br><span class="line">这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。</span><br><span class="line">    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序</span><br><span class="line">算法实现： function quickSort (arr) &#123;</span><br><span class="line">if （arr.length &lt;= 1） &#123;return arr&#125;</span><br><span class="line">var destIndex = Math.floor(arr.length/2)</span><br><span class="line">var left = [], right = [];</span><br><span class="line">var dest = arr.splice(destIndex,1)[0];</span><br><span class="line">for (var i =0;i&lt;arr.length;i++)&#123;</span><br><span class="line">if (arr[i]&lt;dest) &#123;</span><br><span class="line">left.push(arr[i])</span><br><span class="line">&#125; else &#123;</span><br><span class="line">right.push(arr[i]) &#125;</span><br><span class="line">return quickSort(left).concat([dest],quickSort(right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。</span><br><span class="line">  实现过程：1.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、数组去重-juejin-im-post-5aed61…"><a href="#五、数组去重-juejin-im-post-5aed61…" class="headerlink" title="五、数组去重 juejin.im/post/5aed61…"></a>五、数组去重 <a href="https://juejin.im/post/5aed6110518825671b026bed#heading-6" target="_blank" rel="noopener">juejin.im/post/5aed61…</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.双重循环</span><br><span class="line">2.indexOf</span><br><span class="line">3.数组排序去重 最快你Olong</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">判断回文字符串：（递归的思想）</span><br><span class="line">1.字符串分隔，倒转，聚合[...obj].reverse().join(&apos;&apos;)</span><br><span class="line">2.字符串头部和尾部，逐次向中间检测 </span><br><span class="line">实现：function isPalindrome(line) &#123;</span><br><span class="line">line += &apos;&apos;;</span><br><span class="line">for (var i=0,j=line.length-1;i&lt;j;i++,j--) &#123;</span><br><span class="line">if (line.chartAt(i) !== line.chartAt(j) &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.递归</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="七、二分查找（有序数组的查找）"><a href="#七、二分查找（有序数组的查找）" class="headerlink" title="七、二分查找（有序数组的查找）"></a>七、二分查找（有序数组的查找）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数</span><br><span class="line"> (1) 一开始,数据范围覆盖整个数组。</span><br><span class="line"> (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。</span><br><span class="line"> (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T</span><br><span class="line">代码实现：function binarySearch (data, dest, start, end)&#123;</span><br><span class="line">var end = end || data.length-1;</span><br><span class="line">var start = start || 0;</span><br><span class="line">var m = Math.floor((start+end)/2);</span><br><span class="line">if (dest&lt;data[m])&#123;</span><br><span class="line">return binarySearch(data, dest, 0, m-1)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return binarySearch(data, dest, m+1, end)</span><br><span class="line">&#125;&#125;</span><br><span class="line">return false</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h4 id="一、动手实现一个bind（原理通过apply，call）"><a href="#一、动手实现一个bind（原理通过apply，call）" class="headerlink" title="一、动手实现一个bind（原理通过apply，call）"></a>一、动手实现一个bind（原理通过apply，call）</h4><p>一句话概括：1.bind()返回一个新函数，并不会立即执行。<br>2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数<br>3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function (obj, arg) &#123;</span><br><span class="line">   var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">   var context = this;</span><br><span class="line">   var bound = function (newArg) &#123;</span><br><span class="line">   arg = arg.concat(Array.prototype.slice.call(newArg);</span><br><span class="line">   return context.apply(obj, arg)</span><br><span class="line">&#125;</span><br><span class="line">  var F =  function () &#123;&#125;  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程</span><br><span class="line">  F.prototype = context.prototype;</span><br><span class="line">  bound.prototype =  new F();</span><br><span class="line">  return bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、-AJAX-（异步的javascript和xml）"><a href="#二、-AJAX-（异步的javascript和xml）" class="headerlink" title="二、 AJAX （异步的javascript和xml）"></a>二、 AJAX （异步的javascript和xml）</h4><p>ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。<br>优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载<br>可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带<br>劣势：不支持back。对搜索引擎的支持比较弱；不容易调试<br>怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，<br>解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getData(url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象</span><br><span class="line">    xhr.open(&apos;get&apos;, url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份</span><br><span class="line">    xhr.send() //发送一个http请求</span><br><span class="line">    xhr.onreadystatechange = function () &#123;  //设置一个http请求状态的函数</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; xhr.status ==200) &#123;</span><br><span class="line">        console.log(xhr.responseText)  // 获取异步调用返回的数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Promise(getData(url)).resolve(data =&gt; data)</span><br><span class="line"></span><br><span class="line"> AJAX状态码：0 - （未初始化）还没有调用send()方法</span><br><span class="line">     1 - （载入）已调用send方法，正在发送请求</span><br><span class="line">     2 - （载入完成呢）send()方法执行完成</span><br><span class="line">     3 - （交互）正在解析相应内容</span><br><span class="line">     4 - （完成）响应内容解析完成，可以在客户端调用了</span><br></pre></td></tr></table></figure><h4 id="三、函数节流（throttle）"><a href="#三、函数节流（throttle）" class="headerlink" title="三、函数节流（throttle）"></a>三、函数节流（throttle）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> function throttle (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        var previous = 0;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            context = this;</span><br><span class="line">            args = arguments;</span><br><span class="line">            if (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、函数防抖（dobounce）"><a href="#四、函数防抖（dobounce）" class="headerlink" title="四、函数防抖（dobounce）"></a>四、函数防抖（dobounce）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debounce (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            var context = this;</span><br><span class="line">            var args = arguments;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                func.apply(context,args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.clone = function() &#123;</span><br><span class="line">  var newObject = this.constructor === Array ? [] : &#123;&#125;  //对象的深拷贝 获取对应的构造函数 [] 或者 &#123;&#125;</span><br><span class="line">  for (let e in this) &#123; //遍历对象的属性 in  this[e]</span><br><span class="line">    newObject[e] = typeof this[e] === &apos;object&apos; ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、实现一个简单的Promise-https-juejin-im-post-5b2f02cd5188252b937548ab"><a href="#六、实现一个简单的Promise-https-juejin-im-post-5b2f02cd5188252b937548ab" class="headerlink" title="六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab"></a>六、实现一个简单的Promise <a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">  constructor (executor) &#123;   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。</span><br><span class="line">    this.status = &apos;pending&apos;,</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 成功存放的数组</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">     // 失败存放法数组</span><br><span class="line">     this.onRejectedCallbacks = [];</span><br><span class="line">    let resolve = (value) =&gt; &#123;</span><br><span class="line">      if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">        this.status = &apos;resolve&apos;;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let reject = (reason) =&gt; &#123;</span><br><span class="line">      if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">        this.status = &apos;reject&apos;;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  then (onFullFilled,onRejected) &#123;</span><br><span class="line">    if (this.status == &apos;resolved&apos;) &#123;</span><br><span class="line">      onFullFilled(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &apos;rejectd&apos;) &#123;</span><br><span class="line">      onRejected(this.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">      this.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">        onFullFilled(this.value);</span><br><span class="line">      &#125;)</span><br><span class="line">      this.onRejectedCallbacks.push(()=&gt; &#123;</span><br><span class="line">          onRejected(this.reason);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&apos;hello world&apos;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p.then((data) =&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;,(err) =&gt;&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="七、发布订阅者模式（观察者模式）"><a href="#七、发布订阅者模式（观察者模式）" class="headerlink" title="七、发布订阅者模式（观察者模式）"></a>七、发布订阅者模式（观察者模式）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var event = &#123;&#125;; // 发布者</span><br><span class="line">event.clientList = [] //发布者的缓存列表</span><br><span class="line"></span><br><span class="line">event.listen = function (fn) &#123;  // 增加订阅者函数</span><br><span class="line">  this.clientList.push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.trigger = function () &#123;  // 发布信息</span><br><span class="line">  for (var i =0;i&lt;this.clientList.length;i++) &#123;</span><br><span class="line">    var fn = this.clientList[i];</span><br><span class="line">    fn.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.listen (function(time) &#123;</span><br><span class="line">  console.log(&apos;正式上班时间为：&apos; +time)</span><br><span class="line">&#125;)</span><br><span class="line">event.trigger (&apos;2018/7&apos;)</span><br></pre></td></tr></table></figure><h4 id="八、手动写一个node服务器"><a href="#八、手动写一个node服务器" class="headerlink" title="八、手动写一个node服务器"></a>八、手动写一个node服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const server = http.createServer((req,res) =&gt; &#123;</span><br><span class="line">if (reu.url == &apos;/&apos;) &#123;</span><br><span class="line">const indexFile = fs.createReadStream(&apos;./index.html&apos;)</span><br><span class="line">req.writeHead(200,&#123;&apos;context-Type&apos;:&apos;text/html;charset = utf8&#125;)</span><br><span class="line">indexFile.pipe(res)</span><br><span class="line">&#125;</span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、CSS问题&quot;&gt;&lt;a href=&quot;#一、CSS问题&quot; class=&quot;headerlink&quot; title=&quot;一、CSS问题&quot;&gt;&lt;/a&gt;一、CSS问题&lt;/h3&gt;&lt;h4 id=&quot;1-flex布局&quot;&gt;&lt;a href=&quot;#1-flex布局&quot; class=&quot;headerlink&quot; title=&quot;1.flex布局&quot;&gt;&lt;/a&gt;1.flex布局&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="复习" scheme="http://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>深信服研发前端岗位实习面经</title>
    <link href="http://yoursite.com/2019/11/05/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%A0%94%E5%8F%91%E5%89%8D%E7%AB%AF%E5%B2%97%E4%BD%8D%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2019/11/05/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%A0%94%E5%8F%91%E5%89%8D%E7%AB%AF%E5%B2%97%E4%BD%8D%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</id>
    <published>2019-11-05T13:11:20.771Z</published>
    <updated>2019-11-05T13:20:53.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深信服研发前端岗位实习面经"><a href="#深信服研发前端岗位实习面经" class="headerlink" title="深信服研发前端岗位实习面经"></a>深信服研发前端岗位实习面经</h1><h3 id="前两轮两轮技术面"><a href="#前两轮两轮技术面" class="headerlink" title="前两轮两轮技术面"></a>前两轮两轮技术面</h3><p>前端也学了有一年了，感觉学得差不多了，就去招聘网站看看岗位要求，</p><blockquote><p>长沙知名互联网公司基本没有😭 昨天逛实习僧，看到长沙有深信服的前端岗位又是招21届的又是vue技术栈 想试试水，投一个。</p></blockquote><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>中间没有录音，凭记忆就这些了，下次一定要准备好复盘</p><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><p><strong>说说项目的亮点，难点</strong>，两次面试都说到了项目，第一次说了购物车模块实现，路由keep-alive生命周期什么的，第二次说的使用async await去失效的图片</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul><li>position relative absolute float</li><li>css的定位</li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li>怎么判断数组数据类型tinstanceof、Object.prototype.toString.call()等</li><li>原生ajax讲代码，请求过程</li><li>怎么原生实现同步ajax</li><li>setTimeout 执行顺序</li><li>异步同步，事件机制</li><li>宏任务与微任务</li><li>说一下get post区别</li><li>dom事件流 冒泡 捕获</li><li>事件代理</li><li>call apply区别</li><li>“==”和“===”的区别</li><li>for of 和for in区别</li></ul><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul><li>讲讲es6学了什么，</li><li>我说了let const 变量提升</li><li>promise async await</li><li>他叫 我说一下 set 和map</li></ul><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ul><li>vue生命周期</li><li>vue router</li><li>组件怎么传参数 父子props emit 同组件 bus</li><li>vuex</li><li>说一下vue与react的区别</li></ul><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><ul><li>说一下Webpack基本概念与配置</li><li>loader与plugin原理与实现 ，这个不太了解，我说一般使用vue-cli自动打包plugin按需加载</li></ul><h3 id="hr面试"><a href="#hr面试" class="headerlink" title="hr面试"></a>hr面试</h3><ul><li>自我介绍</li><li>说一说你平时怎么学习，</li><li>公司项目跟自己写项目区别，</li><li>说一说你看过什么书 ，</li><li>说一说你遇到的最大的困难，</li><li>还有什么问的吗，问他新人培训机制 是怎样的</li></ul><hr><p><strong>没想到一次试水面试，三轮面试就这样过了，上午面试第一个电话还在健身房洗澡，没接，打过去裤子都没穿，边穿衣服边面试，面完没想到说我还行😇</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深信服研发前端岗位实习面经&quot;&gt;&lt;a href=&quot;#深信服研发前端岗位实习面经&quot; class=&quot;headerlink&quot; title=&quot;深信服研发前端岗位实习面经&quot;&gt;&lt;/a&gt;深信服研发前端岗位实习面经&lt;/h1&gt;&lt;h3 id=&quot;前两轮两轮技术面&quot;&gt;&lt;a href=&quot;#前两轮两轮技术面&quot; class=&quot;headerlink&quot; title=&quot;前两轮两轮技术面&quot;&gt;&lt;/a&gt;前两轮两轮技术面&lt;/h3&gt;&lt;p&gt;前端也学了有一年了，感觉学得差不多了，就去招聘网站看看岗位要求，&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;长沙知名互联网公司基本没有😭 昨天逛实习僧，看到长沙有深信服的前端岗位又是招21届的又是vue技术栈 想试试水，投一个。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="实习" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>服务器部署node新手教程（二）</title>
    <link href="http://yoursite.com/2019/10/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2019-10-31T11:09:48.742Z</published>
    <updated>2020-01-02T12:39:13.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器部署node教程（二）"><a href="#服务器部署node教程（二）" class="headerlink" title="服务器部署node教程（二）"></a>服务器部署node教程（二）</h1><blockquote><p>期间经历了很多坑，多数还是找到了解决办法，相信经历了第一次，以后就能孰能生巧了。</p></blockquote><h3 id="安装最新的node-js环境"><a href="#安装最新的node-js环境" class="headerlink" title="安装最新的node.js环境"></a>安装最新的node.js环境</h3><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p><code>ssh 用户名</code></p><p><code>yum update -y</code>更新</p><p><code>yum install -y nodejs</code>安装nodejs</p><p>查看结果无误，不过版本太低低 删掉 rm</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572102034266.png" alt="1572102034266"></p><p><strong>去官网下</strong></p><p><code>https://nodejs.org/dist/</code></p><p>我下载的最新13版本</p><p><code>wget https://nodejs.org/dist/v13.0.1//node-v13.0.1-linux-x64.tar.xz</code></p><p>解压</p><p><code>tar -xvJf node-v13.0.1-linux-x64.tar.xz</code></p><p>利用软链接放到环境变量 必须用绝对路径 ，路径自己ls查看</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572105757441.png" alt="1572105757441"></p><p>成功🤞</p><h3 id="通过VsCode-ftp-连接接服务器"><a href="#通过VsCode-ftp-连接接服务器" class="headerlink" title="通过VsCode ftp 连接接服务器"></a>通过VsCode ftp 连接接服务器</h3><p>vscode安装插件<code>sftp</code></p><p><code>ctrl+shift+p</code>搜索<code>sftp:Config</code></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572106834768.png" alt="1572106834768"></p><p>配置config，用法字面意思能看懂，更复杂配置搜文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Jason"</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"47.103.209.82"</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"sftp"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"remotePath"</span>: <span class="string">"/home/frontend"</span>,</span><br><span class="line">    <span class="attr">"uploadOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"ignore"</span>: [</span><br><span class="line">        <span class="string">".vscode"</span>,</span><br><span class="line">        <span class="string">".git"</span>,</span><br><span class="line">        <span class="string">".DS_Store"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"syncOption"</span>: &#123;</span><br><span class="line">        <span class="attr">"delete"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"update"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"watcher"</span>: &#123;</span><br><span class="line">        <span class="attr">"files"</span>: <span class="string">"**/*"</span>,</span><br><span class="line">        <span class="attr">"autoUpload"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"autoDelete"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"privateKeyPath"</span>: <span class="string">"~/.ssh/id_rsa"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572145404172.png" alt="1572145404172"></p><p>右键可以拉取推送到服务器</p><h3 id="配置nginx-反向代理"><a href="#配置nginx-反向代理" class="headerlink" title="配置nginx 反向代理"></a>配置nginx 反向代理</h3><p>安装<code>yum install -y nginx</code></p><p>配置nginx.conf，监听服务器本地的5000端口，详细配置请看nginx文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:3000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推入服务器，修改为可执行权限</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572154533239.png" alt="1572154533239"></p><p>覆盖掉原来的nginx配置文件</p><p><code># cp nginx.conf /etc/nginx/nginx.conf</code></p><p>重启nginx</p><p><code># systemctl restart nginx</code></p><p>浏览器输入ip，返回nginx error说明已经配上了</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572154823450.png" alt="1572154823450"></p><p>在服务器安装个express</p><p><code>npm install express -S</code></p><p>测试一下</p><p>趴到本地，建一个index.js测试文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理静态文件</span></span><br><span class="line">app.use(express.static(<span class="string">'client/dist'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, <span class="string">'client'</span>, <span class="string">'dist'</span>, <span class="string">'index.html'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/api/datas'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        name: <span class="string">'Jason'</span>,</span><br><span class="line">        wechat: <span class="string">'wjcyx99'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Server running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>推到服务器，运行 <code>node index.js</code><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572156101543.png" alt="1572156101543"></p><p>浏览器查看结果，成功👍</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572156042839.png" alt="1572156042839"></p><h3 id="创建全局模块软链接"><a href="#创建全局模块软链接" class="headerlink" title="创建全局模块软链接"></a>创建全局模块软链接</h3><p>刚刚 <code>cnpm install -g @vue/cli</code>安装个vue脚手架</p><p>找到vue 在这里</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572157762872.png" alt="1572157762872"></p><p>放到全局，有效果</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572157803313.png" alt="1572157803313"></p><p>使用forever 后台运行</p><p><a href="https://github.com/foreversd/forever" target="_blank" rel="noopener">https://github.com/foreversd/forever</a></p><p><code>npm install forever -g</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ forever start app.js          #启动</span><br><span class="line">$ forever stop app.js           #关闭</span><br></pre></td></tr></table></figure><h3 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h3><p>实验做得差不多了，给我的CityMALL打包上线</p><h3 id="linux下安装mongodb"><a href="#linux下安装mongodb" class="headerlink" title="linux下安装mongodb"></a>linux下安装mongodb</h3><ol><li>在官方下找到下载路径,CentOS红帽子公司的</li></ol><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572253297039.png" alt="1572253297039"></p><p><code>wget 路径</code></p><ol start="2"><li>下载完后解压到这个目录，没有创建</li></ol><p><code>tar -zxvf mongodb-linux-x86_64-rhel70-4.2.1.tgz -C /usr/local/mongoDB/</code></p><p>名字太长了，改个名<code># mv mongodb-linux-x86_64-rhel70-4.2.1 mongodbserver</code></p><ol start="3"><li><p>创建data数据，log日志，etc配置 文件夹</p><p>创建配置文件mongodb.conf</p></li></ol><p><code>cd /usr/local/mongoDB/mongodbserver/etc</code></p><p><code>vim mongodb.conf</code></p><blockquote><p>从mongodb3.2开始默认的存储引擎是WiredTiger，3.3版本之前的默认存储引擎是MMAPv1，mongodb4.x版本不再支持MMAPv1存储引擎。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/usr/local/mongoDB/mongodbserver/data/db #数据存放</span><br><span class="line">logpath=/usr/local/mongoDB/mongodbserver/data/logs/mongodb.log #日志存放</span><br><span class="line">port=27017 #端口</span><br><span class="line">logappend=true #追加方式写日志  </span><br><span class="line">noauth=true #不启用验证  </span><br><span class="line">fork=true #可在后台运行</span><br><span class="line">journal=true #每次写入会记录一条操作</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>添加环境变量</strong></li></ol><ul><li>在/etc/profile文件中，文末添加 export <code>vim /etc profile</code></li></ul><p><code>export PATH=$PATH:/usr/local/mongoDB/mongodbserver/bin</code></p><p>执行``source /etc/profile`，使系统环境变量立即生效</p><ul><li>将mongo路径软链到/usr/bin路径下，方便随处执行mongo命令</li></ul><p>执行命令: <code>ln -s /usr/local/mongoDB/mongodbserver/bin/mongo /usr/bin/mongo</code></p><p>通过配置文件运行，mongod</p><p><code># mongod --config /usr/local/mongoDB/mongodbserver/etc/mongodb.conf</code></p><p>运行mongo成功👍</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572262020655.png" alt="1572262020655"></p><p>到database 初始化mongoDB创建schema</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572442011030.png" alt="1572442011030"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="keyword">const</span> db = <span class="string">"mongodb://localhost/shoppingMall"</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">exports.initSchemas = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    glob.sync(resolve(__dirname, <span class="string">'./schema'</span>, <span class="string">'**/*.js'</span>)).forEach(<span class="built_in">require</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库导入，修正"><a href="#数据库导入，修正" class="headerlink" title="数据库导入，修正"></a>数据库导入，修正</h3><p>之前写了api，直接在浏览器中输入，执行命令</p><p>之前的白酒分类是错的把它修正</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572488999983.png" alt="1572488999983"></p><h3 id="老是出现node-modules错误"><a href="#老是出现node-modules错误" class="headerlink" title="老是出现node_modules错误"></a>老是出现node_modules错误</h3><p>windows<code>cnpm install rimraf -g</code></p><p><code>rm -f /node_modules</code></p><p>linux <code>rm -rf node_modules</code></p><p>一般都是把node_modules删除重新下载<code>cnpm install</code>，有些还不能删除强行移动文件夹就行了</p><h3 id="不挂断在后台运行"><a href="#不挂断在后台运行" class="headerlink" title="不挂断在后台运行"></a>不挂断在后台运行</h3><ol><li><p>nohup<br>nohup 是 no hang up 的缩写，就是不挂断的意思。nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。</p></li><li><p>&amp;</p><p>&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出。</p></li></ol><p>使用命令 nohup COMMAND &amp; 这样就能使命令永久的执行下去，关闭终端窗口、Ctrl+c 、断开SSH连接都不会影响其运行，并且可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件。</p><h3 id="前台打包成静态文件"><a href="#前台打包成静态文件" class="headerlink" title="前台打包成静态文件"></a>前台打包成静态文件</h3><p>​ <code>npm run build</code> 生成dist文件夹放入service，直接就可以使用了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> staticFiles = <span class="built_in">require</span>(<span class="string">'koa-static'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 dist目录为静态资源目录，用来存放 js css images 等</span></span><br><span class="line">app.use(staticFiles(path.resolve(__dirname, <span class="string">"./dist"</span>)))</span><br></pre></td></tr></table></figure><p>在手机测试成功后心情豁然开朗😎</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572520037662.png" alt="1572520037662"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;服务器部署node教程（二）&quot;&gt;&lt;a href=&quot;#服务器部署node教程（二）&quot; class=&quot;headerlink&quot; title=&quot;服务器部署node教程（二）&quot;&gt;&lt;/a&gt;服务器部署node教程（二）&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;期间经历了很多坑，多数还是找到了解决办法，相信经历了第一次，以后就能孰能生巧了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;安装最新的node-js环境&quot;&gt;&lt;a href=&quot;#安装最新的node-js环境&quot; class=&quot;headerlink&quot; title=&quot;安装最新的node.js环境&quot;&gt;&lt;/a&gt;安装最新的node.js环境&lt;/h3&gt;
    
    </summary>
    
    
      <category term="服务器部署" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="部署" scheme="http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>阿里云部署新手教程（一）（购买服务器，免密登陆）</title>
    <link href="http://yoursite.com/2019/10/25/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/25/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2019-10-25T15:20:21.851Z</published>
    <updated>2020-01-02T12:39:13.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里云部署项目新手教程（一）"><a href="#阿里云部署项目新手教程（一）" class="headerlink" title="阿里云部署项目新手教程（一）"></a>阿里云部署项目新手教程（一）</h1><h2 id="（购买服务器，免密登陆）"><a href="#（购买服务器，免密登陆）" class="headerlink" title="（购买服务器，免密登陆）"></a>（购买服务器，免密登陆）</h2><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p>阿里云有学生优惠10元一个月，我选择的是轻量应用服务器，有ssd内存，更高的带宽，但是限量1000G应该够用。选择系统镜像CentOS操作系统。</p><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p>轻量应用服务器操作起来更简单。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572003725828.png" alt="1572003725828"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572004461160.png" alt="1572004461160"></p><h3 id="如何远程连接"><a href="#如何远程连接" class="headerlink" title="如何远程连接"></a>如何远程连接</h3><p>打开cmd终端输入<code>ssh root@0.0.0.0</code>root表示根用户名@后面接公网IP地址</p><p>连上来了</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572004847359.png" alt="1572004847359"></p><h3 id="保存ssh公钥免密登陆"><a href="#保存ssh公钥免密登陆" class="headerlink" title="保存ssh公钥免密登陆"></a>保存ssh公钥免密登陆</h3><p>终端 在~目录下 cd .ssh 进去.ssh文件夹，输入，没有ssh文件夹 创建 <code>md .ssh</code> bash<code>mkdir</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "myemail@myemail.com"</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/home/Administrator/.ssh/id_rsa): C:\Users\Administrator\.ssh\id_rsa</span><br></pre></td></tr></table></figure><p>然后它会要你填写地址，dos得自己填，要不然会报错，因为unix命令都是相反的斜杠，成功之后生成了公钥私钥文件</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572008937745.png" alt="1572008937745"></p><p><strong>然后改回bash终端写命令，dos cmd 太不兼容了😥，全是坑，用git bash，ubantu bash 都可</strong></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572009417347.png" alt="1572009417347"></p><p><code>scp id_rsa.pub root@0.0.0.0:.</code></p><p>解释：复制 这个公钥 到你服务器root用户下的（默认文件夹下<code>:.</code>）</p><p>登陆服务器检查一下，文件已经过来了</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572009688607.png" alt="1572009688607"></p><p><code># cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>把公钥文件追加进来</p><p><code>vim</code>打开这个文件确认一下</p><p>然后重启一下<code># systemctl restart sshd</code></p><p>回到本地，删了公钥<code>$ rm id_rsa.pub</code></p><p>新建配置文件</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572010250446.png" alt="1572010250446"></p><p><code>$ code config</code>vscode 打开config,配置</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572010927402.png" alt="1572010927402"></p><p><code>ssh 用户名</code>免密登陆成功😎</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572010957144.png" alt="1572010957144"></p><h3 id="git-push-到github-ssh-免密推送"><a href="#git-push-到github-ssh-免密推送" class="headerlink" title="git push 到github ssh 免密推送"></a>git push 到github ssh 免密推送</h3><p>把之前的公钥写进来</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572015770953.png" alt="1572015770953"></p><p>把https推送修改成ssh推送</p><p><code>git remote set-url origin +ssh链接</code></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572015579162.png" alt="1572015579162"></p><p>免密推送成功😎</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/nodeToService/1572015804042.png" alt="1572015804042"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阿里云部署项目新手教程（一）&quot;&gt;&lt;a href=&quot;#阿里云部署项目新手教程（一）&quot; class=&quot;headerlink&quot; title=&quot;阿里云部署项目新手教程（一）&quot;&gt;&lt;/a&gt;阿里云部署项目新手教程（一）&lt;/h1&gt;&lt;h2 id=&quot;（购买服务器，免密登陆）&quot;&gt;&lt;a href=&quot;#（购买服务器，免密登陆）&quot; class=&quot;headerlink&quot; title=&quot;（购买服务器，免密登陆）&quot;&gt;&lt;/a&gt;（购买服务器，免密登陆）&lt;/h2&gt;&lt;h3 id=&quot;购买服务器&quot;&gt;&lt;a href=&quot;#购买服务器&quot; class=&quot;headerlink&quot; title=&quot;购买服务器&quot;&gt;&lt;/a&gt;购买服务器&lt;/h3&gt;&lt;p&gt;阿里云有学生优惠10元一个月，我选择的是轻量应用服务器，有ssd内存，更高的带宽，但是限量1000G应该够用。选择系统镜像CentOS操作系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务器部署" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="部署，服务器" scheme="http://yoursite.com/tags/%E9%83%A8%E7%BD%B2%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>1024程序员节+项目总结+日常</title>
    <link href="http://yoursite.com/2019/10/24/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/"/>
    <id>http://yoursite.com/2019/10/24/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/</id>
    <published>2019-10-24T15:58:56.751Z</published>
    <updated>2020-01-02T12:39:13.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1024程序员节-项目总结-日常"><a href="#1024程序员节-项目总结-日常" class="headerlink" title="1024程序员节+项目总结+日常"></a>1024程序员节+项目总结+日常</h1><blockquote><p>今天程序员过节，自己呢，从学生向程序员慢慢进发了。</p></blockquote><p>学习了一年多，觉得自己也算是入门前端这个领域了。虽然是很日常的一天，但纪念第一次有了从学生到程序员的认同感的节日是有意义的。</p><a id="more"></a><!-- build time:Mon Jan 13 2020 17:49:55 GMT+0800 (GMT+08:00) --><p><strong>说说我今天日常的一天。</strong></p><p>上午买了腾讯课堂的项目部署打折，这个商城项目写得也差不多了，在手机上测试了一下，修改了一些些bug</p><p><strong>1.点击商品详情页商品信息重复没有刷新</strong></p><p>是由于之前为了页面不刷新加了<code>&lt;keep-alive&gt;</code>导致所有页面重复加载就不会触发刷新。</p><p>在router index.js 文件下 <code>meta: { keepAlive:false //不需要被缓存的组件 }</code>在不需要缓存的页面加上配置。</p><p>在App.vue 文件下 对需要缓存的页面做一个判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;$route.meta.keepAlive&quot; /&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>2.如何在手机端调试写好的程序</strong></p><ul><li><p>首先要在同一个局域网下，手机与电脑在同一个局域网内，<strong>把防火墙关了</strong>，防火墙是个大坑，试了好久</p></li><li><p>cmd终端命令<code>ipconfig</code> 查看无线网的IP地址，在config&gt;index.js 配置下 <code>host: &#39;192.168.137.1&#39;,</code> 域名改成你的IP</p></li><li><p>请求接口配置文件也改成你的IP<code>const LOCALURL = &quot;http://192.168.137.1:3000/&quot;</code>成功访问后台接口</p></li><li><p>如果有json-server 模拟数据，在package.json=&gt;scripts下把host改为0.0.0.0就可以让所有IP访问到</p></li></ul><p><code>&quot;json:server&quot;: &quot;json-server --watch --host 0.0.0.0 --port 3001 goods.json&quot;</code></p><h3 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h3><p>前期跟着老师视屏做，照着视频敲，学完后发现这个项目不太完善，页面很多功能都没做，老师的教程也结束了，烂尾了，在掘金看技术胖的赞那么多，觉得看他的视频总没错，只能说期望太高了。那就只有自己就把一些不满意的地方都改了，这样也好，能有自己思考的空间。</p><p><strong>个人页面</strong>直接没讲，我就自己加了有赞的个人页面框架，把<strong>登陆注册</strong>加进去了。其他功能接口都没写。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/vue_shopping/1572017219183.png" alt="1572017219183"></p><p><strong>购物车</strong>UI也做了相应优化，计算总价，checkbox。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/vue_shopping/1572017252727.png" alt="1572017252727"></p><p><strong>商品详情</strong>统一用了vantUI组件，之前实在难看。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/vue_shopping/1572017542406.png" alt="1572017542406"></p><p><strong>列表商品</strong>之前爬的图片链接失效，直接在后台把失效图片给洗了一遍。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/vue_shopping/1572017315053.png" alt="1572017315053"></p><p>使用axios请求，把能请求到的数据写入新文件，请求不到就抛弃。之前先存一个数组，再一概写进去这是不行的，会返回一个空数组。多个异步请求，函数直接返回了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">newData.map(<span class="keyword">async</span>(value, index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> result = <span class="keyword">await</span> axios.get(value.IMAGE1)</span><br><span class="line">                <span class="comment">//console.log(value)</span></span><br><span class="line">                fs.appendFile(<span class="string">'./data_json/newGoods2.json'</span>,<span class="built_in">JSON</span>.stringify(value)+<span class="string">','</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err) &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err + <span class="string">'bb'</span>)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>也算彻底弄懂了JS的运行顺序，异步同步，宏任务微任务，还有async/await，看了几篇文章。以后再单独拿出来一篇文章总结把。</p><p>mongoDB数据库，增加了一个休闲食品类别，把食品饮料栏变为两栏，要不然这一栏的子分类太多了，还有一个白酒的分类，里面数据却全是生鲜，技术胖老师完全不走心。我全都改了。</p><p>后期，还要把<strong>首页的所有图片链接跳转商品详情</strong>给完善了，</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/vue_shopping/1572017598297.png" alt="1572017598297"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/vue_shopping/1572017627898.png" alt="1572017627898"></p><p><em>第二天完善了</em></p><p>首页分类跳到分类详情，在分类栏绑定@click方法，传入ID值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goCategory(index)&#123;</span><br><span class="line">  <span class="comment">//console.log(index)</span></span><br><span class="line">  <span class="keyword">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">'CategoryList'</span>,<span class="attr">params</span>:&#123;<span class="attr">mallCategoryId</span>:index&#125;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到商品分类，然后在<code>activated()</code>钩子函数中把具体页号传过来，默认第一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activated() &#123;</span><br><span class="line">  <span class="keyword">let</span> firstCategoryIndex = <span class="keyword">this</span>.$route.params.mallCategoryId || <span class="number">0</span></span><br><span class="line">  <span class="keyword">this</span>.clickCategory(firstCategoryIndex, firstCategoryIndex + <span class="number">1</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>应用clickCategory方法点击到指定分类栏。</p><p>之前写在<code>create()</code>钩子中，没有效果，问题页面是keep-alive存在缓存，不会重新加载。</p><p><strong>知识点</strong>: 钩子函数的执行顺序</p><p>使用<code>keep-alive</code>的初次加载顺序</p><p><code>beforeRouteEnter --&gt; created --&gt; mounted --&gt; activated --&gt; deactivated</code></p><p>再次进入缓存的页面，只会触发<code>beforeRouteEnter --&gt;activated --&gt; deactivated</code></p><p>created和mounted不会再执行。</p><p>关于vue的路由还需要继续升入了解，现在知道的还太浅了。</p><p>之后学习一下怎么挂在服务器。</p><hr><h3 id="说一说傍晚的狗血京东校招"><a href="#说一说傍晚的狗血京东校招" class="headerlink" title="说一说傍晚的狗血京东校招"></a>说一说傍晚的狗血京东校招</h3><p>群里通知说今天晚上有京东的校招，下午赶紧把简历完善了去试试水。</p><p>兴致勃勃去那里，开始宣讲，先是说京东怎么待遇好，几万员工，什么环境，强东哥怎么怎么厉害。然后ppt开始显示<strong>京东顾问</strong>？？？我觉得好像是京东，不对劲，讲师开始宣传怎么当客服来了。三千一个月的京东<strong>客服</strong>，太会蹭京东的热点了，还只招客服3000一个月。。。“就没人提问了吗，都是家里有矿的可以走了”，然后我叫室友一起溜走了。本科生当客服，真有人愿意吗？纯体力活，不值得给强哥卖命，有时间还是学点真本事吧。</p><h3 id="再说一说上周的狗血拓维"><a href="#再说一说上周的狗血拓维" class="headerlink" title="再说一说上周的狗血拓维"></a>再说一说上周的狗血拓维</h3><p>去拓维看热闹。校招招60个java，就5个前端，笔试题全是java，就只有两个前端题一个填空，数组合并字符串：<code>arr.join(&#39;&#39;)</code>，手写代码打点计时器用<code>setinterval+闭包函数</code>写了，交个白卷勾个前端，走了。</p><p>结果回来路上打电话，叫回去面试，面试官说他是团队LEADER，java后台但是懂一些前端。</p><p>面试官问我小程序生命周期，学了几个月我有点模糊忘记了，硬着头皮把vue生命周期说得头头是道,面试官说我‘说得不错’。</p><p>然后要我写个移动登陆布局，他rem都不知道，他觉得rem是栅格布局，跟他解释根元素字体大小都不懂，他把rem理解为栅格布局？？</p><p><code>transform：translate</code>也不知道我说是位移,他硬是说动画，我说动画是<code>transition</code>或者用<code>animation</code>可以实现，估计他没听懂，说我平常是不是复制粘贴。</p><p>我说我没有，我都是自己写代码，我觉得可能登陆布局没什么好证明实力的，立马给他手写了个双飞翼部。就叫我等通知就没有然后了。</p><p>我觉得根本不懂前端基础就来面试别人，不懂装懂批判别人很可耻，现场没有前端可以电话别的前端同事阿。</p><p>拉黑拓维公司，大一期末的时候，给粮食局装新系统，招实习生去装，我积极报名了，期末过后培训了三天结果还是水了我们四个大一的，就去了一个大一，其余都是大二大三一个没刷，根本没有一行代码，就是装系统体力活，凭什么刷我们低年级。</p><p>算是看透这个公司了，给政府，华为做外包，其美名曰：‘战略合作’。</p><hr><p>吐槽归吐槽，毕竟二流本科，也没什么好资源，要怪也只能怪自己高中只有这个水平进这样的学校。有机会进来工作室，也算是一种幸运，看外面的世界，心态格局就跟班上有些还在浑浑噩噩度日不是一个档次了，努力努力争取跳出平凡。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1024程序员节-项目总结-日常&quot;&gt;&lt;a href=&quot;#1024程序员节-项目总结-日常&quot; class=&quot;headerlink&quot; title=&quot;1024程序员节+项目总结+日常&quot;&gt;&lt;/a&gt;1024程序员节+项目总结+日常&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;今天程序员过节，自己呢，从学生向程序员慢慢进发了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;学习了一年多，觉得自己也算是入门前端这个领域了。虽然是很日常的一天，但纪念第一次有了从学生到程序员的认同感的节日是有意义的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
